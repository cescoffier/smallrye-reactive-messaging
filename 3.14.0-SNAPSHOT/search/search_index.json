{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SmallRye Reactive Messaging SmallRye Reactive Messaging is a framework for building event-driven, data streaming, and event-sourcing applications. It lets your application interact using various messaging technologies such as Apache Kafka, AMQP or MQTT. The framework provides a flexible programming model bridging CDI and event-driven. SmallRye Reactive Messaging is an implementation of the Eclipse MicroProfile Reactive Messaging specification 2.0.1. Event-Driven Architectures SmallRye Reactive Messaging is used in Quarkus , and Open Liberty . Start with the xref:getting-started.adoc[Getting Started] guide to know how it can be used and introduce various features.","title":"Home"},{"location":"#smallrye-reactive-messaging","text":"SmallRye Reactive Messaging is a framework for building event-driven, data streaming, and event-sourcing applications. It lets your application interact using various messaging technologies such as Apache Kafka, AMQP or MQTT. The framework provides a flexible programming model bridging CDI and event-driven. SmallRye Reactive Messaging is an implementation of the Eclipse MicroProfile Reactive Messaging specification 2.0.1. Event-Driven Architectures SmallRye Reactive Messaging is used in Quarkus , and Open Liberty . Start with the xref:getting-started.adoc[Getting Started] guide to know how it can be used and introduce various features.","title":"SmallRye Reactive Messaging"},{"location":"getting-started/","text":"Getting Started // TODO The easiest to start using SmallRye Reactive Messaging is to use a simple Java Main class. Creates a Maven project, and include the following dependency in your pom.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-provider </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny-reactive-streams-operators </artifactId> <version> 1.1.2 </version> </dependency> <dependency> <groupId> org.jboss.weld.se </groupId> <artifactId> weld-se-core </artifactId> <version> 3.1.8.Final </version> </dependency> <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config </artifactId> <version> 2.7.0 </version> </dependency> Once created, create a class file with a public static void main(String... args) method: 1 2 3 4 5 6 7 8 9 10 11 12 13 package quickstart ; import javax.enterprise.context.ApplicationScoped ; import javax.enterprise.inject.se.SeContainerInitializer ; @ApplicationScoped public class Main { public static void main ( String [] args ) { SeContainerInitializer . newInstance (). initialize (); } } Ok, so far so good, but we need event-driven beans . For instance: [source, java] include::example$quickstart/MyBean.java[] Finally, you need an empty beans.xml . Copy the following content to src/main/resources/META-INF/beans.xml : [source,xml] Once everything is setup, you should be able to run the application using: [source,bash] mvn compile exec:java -Dexec.mainClass=quickstart.Main Running the previous example should give the following output: [source] HELLO SMALLRYE REACTIVE MESSAGE [NOTE] SmallRye Reactive Messaging uses JBoss-logging to log. For testing purpose, you can simply add a logging.properties file in ${basedir}/src/main/resources/logging.properties Then run the application using: ==== [source,bash] mvn package exec:java -Dexec.mainClass=quickstart.Main -Djava.util.logging.config.file=${basedir}/src/main/resources/logging.properties Example logging.properties: [source,bash] handlers=java.util.logging.ConsoleHandler java.util.logging.ConsoleHandler.level=FINEST java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter java.util.logging.SimpleFormatter.format=[%1$tF %1$tT] [%4$-7s] %5$s %n .level=OFF acme.level=FINEST","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"// TODO The easiest to start using SmallRye Reactive Messaging is to use a simple Java Main class. Creates a Maven project, and include the following dependency in your pom.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-provider </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny-reactive-streams-operators </artifactId> <version> 1.1.2 </version> </dependency> <dependency> <groupId> org.jboss.weld.se </groupId> <artifactId> weld-se-core </artifactId> <version> 3.1.8.Final </version> </dependency> <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config </artifactId> <version> 2.7.0 </version> </dependency> Once created, create a class file with a public static void main(String... args) method: 1 2 3 4 5 6 7 8 9 10 11 12 13 package quickstart ; import javax.enterprise.context.ApplicationScoped ; import javax.enterprise.inject.se.SeContainerInitializer ; @ApplicationScoped public class Main { public static void main ( String [] args ) { SeContainerInitializer . newInstance (). initialize (); } } Ok, so far so good, but we need event-driven beans . For instance:","title":"Getting Started"},{"location":"getting-started/#source-java","text":"","title":"[source, java]"},{"location":"getting-started/#includeexamplequickstartmybeanjava","text":"Finally, you need an empty beans.xml . Copy the following content to src/main/resources/META-INF/beans.xml :","title":"include::example$quickstart/MyBean.java[]"},{"location":"getting-started/#sourcexml","text":"Once everything is setup, you should be able to run the application using:","title":"[source,xml]"},{"location":"getting-started/#sourcebash","text":"","title":"[source,bash]"},{"location":"getting-started/#mvn-compile-execjava-dexecmainclassquickstartmain","text":"Running the previous example should give the following output:","title":"mvn compile exec:java -Dexec.mainClass=quickstart.Main"},{"location":"getting-started/#source","text":"HELLO SMALLRYE REACTIVE MESSAGE","title":"[source]"},{"location":"getting-started/#note","text":"SmallRye Reactive Messaging uses JBoss-logging to log. For testing purpose, you can simply add a logging.properties file in ${basedir}/src/main/resources/logging.properties Then run the application using: ====","title":"[NOTE]"},{"location":"getting-started/#sourcebash_1","text":"","title":"[source,bash]"},{"location":"getting-started/#mvn-package-execjava-dexecmainclassquickstartmain-djavautilloggingconfigfilebasedirsrcmainresourcesloggingproperties","text":"Example logging.properties:","title":"mvn package exec:java -Dexec.mainClass=quickstart.Main -Djava.util.logging.config.file=${basedir}/src/main/resources/logging.properties"},{"location":"getting-started/#sourcebash_2","text":"handlers=java.util.logging.ConsoleHandler java.util.logging.ConsoleHandler.level=FINEST java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter java.util.logging.SimpleFormatter.format=[%1$tF %1$tT] [%4$-7s] %5$s %n .level=OFF acme.level=FINEST","title":"[source,bash]"},{"location":"camel/camel-processor/","text":"The processor pattern using Camel Using the processor pattern, you can consume on a channel using a Camel component, and produce on a channel using another Camel component. In that case, the headers present in the incoming metadata will be forwarded in the outgoing metadata. Example Let\u2019s imagine you want to read messages from a Nats subject, process it and produce a message on a Kafka topic. 1 2 3 4 5 6 7 mp.messaging.incoming.mynatssubject.connector = smallrye-camel # <1> mp.messaging.incoming.mynatssubject.endpoint-uri = nats:mynatssubject # <2> mp.messaging.outgoing.mykafkatopic.connector = smallrye-camel # <3> mp.messaging.outgoing.mykafkatopic.endpoint-uri = kafka:mykafkatopic# <4> camel.component.nats.servers = 127.0.0.1:5555 # <5> camel.component.kafka.brokers = 127.0.0.1:9092 # <6> 1. Sets the connector for the mynatssubject channel 2. Configures the endpoint-uri for nats subject 3. Sets the connector for the mykafkatopic channel 4. Configures the endpoint-uri for the kafka topic 5. Sets the URL of the nats server to use 6. Sets the URL of a kafka broker to use 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package camel.processor ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; @ApplicationScoped public class CamelProcessor { @Incoming ( \"mynatssubject\" ) @Outgoing ( \"mykafkatopic\" ) public byte [] process ( byte [] message ) { // do some logic return message ; } }","title":"Implementing Camel processor"},{"location":"camel/camel-processor/#the-processor-pattern-using-camel","text":"Using the processor pattern, you can consume on a channel using a Camel component, and produce on a channel using another Camel component. In that case, the headers present in the incoming metadata will be forwarded in the outgoing metadata.","title":"The processor pattern using Camel"},{"location":"camel/camel-processor/#example","text":"Let\u2019s imagine you want to read messages from a Nats subject, process it and produce a message on a Kafka topic. 1 2 3 4 5 6 7 mp.messaging.incoming.mynatssubject.connector = smallrye-camel # <1> mp.messaging.incoming.mynatssubject.endpoint-uri = nats:mynatssubject # <2> mp.messaging.outgoing.mykafkatopic.connector = smallrye-camel # <3> mp.messaging.outgoing.mykafkatopic.endpoint-uri = kafka:mykafkatopic# <4> camel.component.nats.servers = 127.0.0.1:5555 # <5> camel.component.kafka.brokers = 127.0.0.1:9092 # <6> 1. Sets the connector for the mynatssubject channel 2. Configures the endpoint-uri for nats subject 3. Sets the connector for the mykafkatopic channel 4. Configures the endpoint-uri for the kafka topic 5. Sets the URL of the nats server to use 6. Sets the URL of a kafka broker to use 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package camel.processor ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; @ApplicationScoped public class CamelProcessor { @Incoming ( \"mynatssubject\" ) @Outgoing ( \"mykafkatopic\" ) public byte [] process ( byte [] message ) { // do some logic return message ; } }","title":"Example"},{"location":"camel/camel/","text":"Apache Camel Connector The Camel connector adds support for Apache Camel to Reactive Messaging. Camel is an open source integration framework let you integrate various systems consuming or producing data. Camel implements the Enterprise Integration Patterns and provides several hundred of components used to access databases, message queues, APIs or basically anything under the sun . Introduction Camel is not a messaging broker. But, it allows your Reactive Messaging application to retrieve data from almost anything and send data to almost anything. So if you want to send Reactive Messaging Message to Telegram or retrieve data from Salesforce or SAP, this is the connector you need. One of the Camel cornerstone is the endpoint and its uri encoding the connection to an external system. For example, file:orders/?delete=true&charset=utf-8 instructs Camel to read the files from the orders directory. URI format and parameters are listed on the component documentation, such as the File component . Using the camel connector To you the camel Connector, add the following dependency to your project: 1 2 3 4 5 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-camel </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> You will also need the dependency of the Camel component you are using. For example, if you want to process files, you would need to add the Camel File Component artifact: 1 2 3 4 5 <dependency> <groupId> org.apache.camel </groupId> <artifactId> camel-file </artifactId> <version> 3.13.0 </version> </dependency> The connector name is: smallrye-camel . So, to indicate that a channel is managed by this connector you need: 1 2 3 4 5 # Inbound mp.messaging.incoming.[channel-name].connector=smallrye-camel # Outbound mp.messaging.outgoing.[channel-name].connector=smallrye-camel","title":"Apache Camel Connector"},{"location":"camel/camel/#apache-camel-connector","text":"The Camel connector adds support for Apache Camel to Reactive Messaging. Camel is an open source integration framework let you integrate various systems consuming or producing data. Camel implements the Enterprise Integration Patterns and provides several hundred of components used to access databases, message queues, APIs or basically anything under the sun .","title":"Apache Camel Connector"},{"location":"camel/camel/#introduction","text":"Camel is not a messaging broker. But, it allows your Reactive Messaging application to retrieve data from almost anything and send data to almost anything. So if you want to send Reactive Messaging Message to Telegram or retrieve data from Salesforce or SAP, this is the connector you need. One of the Camel cornerstone is the endpoint and its uri encoding the connection to an external system. For example, file:orders/?delete=true&charset=utf-8 instructs Camel to read the files from the orders directory. URI format and parameters are listed on the component documentation, such as the File component .","title":"Introduction"},{"location":"camel/camel/#using-the-camel-connector","text":"To you the camel Connector, add the following dependency to your project: 1 2 3 4 5 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-camel </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> You will also need the dependency of the Camel component you are using. For example, if you want to process files, you would need to add the Camel File Component artifact: 1 2 3 4 5 <dependency> <groupId> org.apache.camel </groupId> <artifactId> camel-file </artifactId> <version> 3.13.0 </version> </dependency> The connector name is: smallrye-camel . So, to indicate that a channel is managed by this connector you need: 1 2 3 4 5 # Inbound mp.messaging.incoming.[channel-name].connector=smallrye-camel # Outbound mp.messaging.outgoing.[channel-name].connector=smallrye-camel","title":"Using the camel connector"},{"location":"camel/receiving-messages-from-camel/","text":"Retrieving data using Camel Camel provides many components. To keep this documentation focused on the integration with Camel, we use the File component . This component let use read files from a directory. So the connector configured with this component creates a Message for each file located in the directory. As soon as a file is dropped in the directory, a new Message is created. Example Let\u2019s imagine you want to read the files from the orders directory and send them to the files channel. Configuring the Camel connector to gets the file from this directory only requires 2 properties: 1 2 mp.messaging.incoming.files.connector = smallrye-camel # <1> mp.messaging.incoming.files.endpoint-uri = file:orders/?delete=true&charset=utf-8 # <2> 1. Sets the connector for the files channel 2. Configures the endpoint-uri Then, your application receives Message<GenericFile<File>> . Note The Camel File component produces org.apache.camel.component.file.GenericFile instances. You can retrieve the actual File using getFile() . You can consume the payload directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package camel.inbound ; import java.io.File ; import javax.enterprise.context.ApplicationScoped ; import org.apache.camel.component.file.GenericFile ; import org.eclipse.microprofile.reactive.messaging.Incoming ; @ApplicationScoped public class CamelFileConsumer { @Incoming ( \"files\" ) public void consume ( GenericFile < File > gf ) { File file = gf . getFile (); // process the file } } You can also retrieve the Message<GenericFile<File>> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package camel.inbound ; import java.io.File ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.apache.camel.component.file.GenericFile ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; @ApplicationScoped public class CamelFileMessageConsumer { @Incoming ( \"files\" ) public CompletionStage < Void > consume ( Message < GenericFile < File >> msg ) { File file = msg . getPayload (). getFile (); // process the file return msg . ack (); } } Deserialization Each Camel component is producing specific objects. As we have seen, the File component produces GenericFile . Refer to the component documentation to check which type is produced. Inbound Metadata Messages coming from Camel contains an instance of IncomingExchangeMetadata in the metadata. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package camel.inbound ; import java.io.File ; import java.util.Optional ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.apache.camel.Exchange ; import org.apache.camel.component.file.GenericFile ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; import io.smallrye.reactive.messaging.camel.IncomingExchangeMetadata ; @ApplicationScoped public class IncomingCamelMetadataExample { @Incoming ( \"files\" ) public CompletionStage < Void > consume ( Message < GenericFile < File >> msg ) { Optional < IncomingExchangeMetadata > metadata = msg . getMetadata ( IncomingExchangeMetadata . class ); if ( metadata . isPresent ()) { // Retrieve the camel exchange: Exchange exchange = metadata . get (). getExchange (); } return msg . ack (); } } This object lets you retrieve the Camel Exchange . Failure Management If a message produced from a Camel exchange is nacked , a failure strategy is applied. The Camel connector supports 3 strategies: fail - fail the application, no more MQTT messages will be processed. (default) The offset of the record that has not been processed correctly is not committed. ignore - the failure is logged, but the processing continue. In both cases, the exchange is marked as rollback only and the nack reason is attached to the exchange. Configuration Reference Attribute ( alias ) Description Type Mandatory Default endpoint-uri The URI of the Camel endpoint (read from or written to) string true failure-strategy Specify the failure strategy to apply when a message produced from a Camel exchange is nacked. Values can be fail (default) or ignore string false fail","title":"Receiving messages from Camel"},{"location":"camel/receiving-messages-from-camel/#retrieving-data-using-camel","text":"Camel provides many components. To keep this documentation focused on the integration with Camel, we use the File component . This component let use read files from a directory. So the connector configured with this component creates a Message for each file located in the directory. As soon as a file is dropped in the directory, a new Message is created.","title":"Retrieving data using Camel"},{"location":"camel/receiving-messages-from-camel/#example","text":"Let\u2019s imagine you want to read the files from the orders directory and send them to the files channel. Configuring the Camel connector to gets the file from this directory only requires 2 properties: 1 2 mp.messaging.incoming.files.connector = smallrye-camel # <1> mp.messaging.incoming.files.endpoint-uri = file:orders/?delete=true&charset=utf-8 # <2> 1. Sets the connector for the files channel 2. Configures the endpoint-uri Then, your application receives Message<GenericFile<File>> . Note The Camel File component produces org.apache.camel.component.file.GenericFile instances. You can retrieve the actual File using getFile() . You can consume the payload directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package camel.inbound ; import java.io.File ; import javax.enterprise.context.ApplicationScoped ; import org.apache.camel.component.file.GenericFile ; import org.eclipse.microprofile.reactive.messaging.Incoming ; @ApplicationScoped public class CamelFileConsumer { @Incoming ( \"files\" ) public void consume ( GenericFile < File > gf ) { File file = gf . getFile (); // process the file } } You can also retrieve the Message<GenericFile<File>> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package camel.inbound ; import java.io.File ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.apache.camel.component.file.GenericFile ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; @ApplicationScoped public class CamelFileMessageConsumer { @Incoming ( \"files\" ) public CompletionStage < Void > consume ( Message < GenericFile < File >> msg ) { File file = msg . getPayload (). getFile (); // process the file return msg . ack (); } }","title":"Example"},{"location":"camel/receiving-messages-from-camel/#deserialization","text":"Each Camel component is producing specific objects. As we have seen, the File component produces GenericFile . Refer to the component documentation to check which type is produced.","title":"Deserialization"},{"location":"camel/receiving-messages-from-camel/#inbound-metadata","text":"Messages coming from Camel contains an instance of IncomingExchangeMetadata in the metadata. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package camel.inbound ; import java.io.File ; import java.util.Optional ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.apache.camel.Exchange ; import org.apache.camel.component.file.GenericFile ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; import io.smallrye.reactive.messaging.camel.IncomingExchangeMetadata ; @ApplicationScoped public class IncomingCamelMetadataExample { @Incoming ( \"files\" ) public CompletionStage < Void > consume ( Message < GenericFile < File >> msg ) { Optional < IncomingExchangeMetadata > metadata = msg . getMetadata ( IncomingExchangeMetadata . class ); if ( metadata . isPresent ()) { // Retrieve the camel exchange: Exchange exchange = metadata . get (). getExchange (); } return msg . ack (); } } This object lets you retrieve the Camel Exchange .","title":"Inbound Metadata"},{"location":"camel/receiving-messages-from-camel/#failure-management","text":"If a message produced from a Camel exchange is nacked , a failure strategy is applied. The Camel connector supports 3 strategies: fail - fail the application, no more MQTT messages will be processed. (default) The offset of the record that has not been processed correctly is not committed. ignore - the failure is logged, but the processing continue. In both cases, the exchange is marked as rollback only and the nack reason is attached to the exchange.","title":"Failure Management"},{"location":"camel/receiving-messages-from-camel/#configuration-reference","text":"Attribute ( alias ) Description Type Mandatory Default endpoint-uri The URI of the Camel endpoint (read from or written to) string true failure-strategy Specify the failure strategy to apply when a message produced from a Camel exchange is nacked. Values can be fail (default) or ignore string false fail","title":"Configuration Reference"},{"location":"camel/sending-messages-to-camel/","text":"Sending data with Camel You can use the Camel connector to send data to almost any type of system. To keep this document focused on the Camel connector, we use the Camel File component. However, the connector can be used with any Camel component. Example Let\u2019s imagine you want to write generated prices into files. Configure your application to write the messages from the prices channel into a files as follows: 1 2 mp.messaging.outgoing.prices.connector = smallrye-camel # <1> mp.messaging.outgoing.prices.endpoint-uri = file:prices/?fileName=${date:now:yyyyMMddssSS}.txt&charset=utf-8 # <2> 1. Sets the connector for the prices channel 2. Configure the endpoint-uri to write into files in the prices directory Important Depending on your implementation of MicroProfile Reactive Messaging, the $ may need to be escaped as follows: $${...} Then, your application must send Message<String> to the prices channel. It can use String payloads as in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package camel.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class CamelPriceProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < String > generate () { // Build an infinite stream of random prices return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . onOverflow (). drop () . map ( x -> random . nextDouble ()) . map ( p -> Double . toString ( p )); } } Or, you can send Message<Double> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package camel.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class CamelPriceMessageProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Message < String >> generate () { // Build an infinite stream of random prices return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()) . map ( p -> Double . toString ( p )) . map ( Message :: of ); } } Serialization The serialization is handled by the Camel component. Refer to the Camel documentation to check which payload type is supported by the component. Outbound Metadata When sending Messages , you can add an instance of OutgoingExchangeMetadata to the message metadata. You can then influence how the outbound Camel Exchange is created, for example by adding properties: 1 2 3 4 5 6 return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()) . map ( p -> Double . toString ( p )) . map ( s -> Message . of ( s ) . addMetadata ( new OutgoingExchangeMetadata () . putProperty ( \"my-property\" , \"my-value\" ))); Acknowledgement The incoming messages are acknowledged when the underlying Camel exchange completes. If the exchange fails, the message is nacked. Configuration Reference Attribute ( alias ) Description Type Mandatory Default endpoint-uri The URI of the Camel endpoint (read from or written to) string true merge Whether the connector should allow multiple upstreams boolean false false","title":"Sending messages to Camel"},{"location":"camel/sending-messages-to-camel/#sending-data-with-camel","text":"You can use the Camel connector to send data to almost any type of system. To keep this document focused on the Camel connector, we use the Camel File component. However, the connector can be used with any Camel component.","title":"Sending data with Camel"},{"location":"camel/sending-messages-to-camel/#example","text":"Let\u2019s imagine you want to write generated prices into files. Configure your application to write the messages from the prices channel into a files as follows: 1 2 mp.messaging.outgoing.prices.connector = smallrye-camel # <1> mp.messaging.outgoing.prices.endpoint-uri = file:prices/?fileName=${date:now:yyyyMMddssSS}.txt&charset=utf-8 # <2> 1. Sets the connector for the prices channel 2. Configure the endpoint-uri to write into files in the prices directory Important Depending on your implementation of MicroProfile Reactive Messaging, the $ may need to be escaped as follows: $${...} Then, your application must send Message<String> to the prices channel. It can use String payloads as in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package camel.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class CamelPriceProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < String > generate () { // Build an infinite stream of random prices return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . onOverflow (). drop () . map ( x -> random . nextDouble ()) . map ( p -> Double . toString ( p )); } } Or, you can send Message<Double> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package camel.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class CamelPriceMessageProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Message < String >> generate () { // Build an infinite stream of random prices return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()) . map ( p -> Double . toString ( p )) . map ( Message :: of ); } }","title":"Example"},{"location":"camel/sending-messages-to-camel/#serialization","text":"The serialization is handled by the Camel component. Refer to the Camel documentation to check which payload type is supported by the component.","title":"Serialization"},{"location":"camel/sending-messages-to-camel/#outbound-metadata","text":"When sending Messages , you can add an instance of OutgoingExchangeMetadata to the message metadata. You can then influence how the outbound Camel Exchange is created, for example by adding properties: 1 2 3 4 5 6 return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()) . map ( p -> Double . toString ( p )) . map ( s -> Message . of ( s ) . addMetadata ( new OutgoingExchangeMetadata () . putProperty ( \"my-property\" , \"my-value\" )));","title":"Outbound Metadata"},{"location":"camel/sending-messages-to-camel/#acknowledgement","text":"The incoming messages are acknowledged when the underlying Camel exchange completes. If the exchange fails, the message is nacked.","title":"Acknowledgement"},{"location":"camel/sending-messages-to-camel/#configuration-reference","text":"Attribute ( alias ) Description Type Mandatory Default endpoint-uri The URI of the Camel endpoint (read from or written to) string true merge Whether the connector should allow multiple upstreams boolean false false","title":"Configuration Reference"},{"location":"camel/using-existing-routes/","text":"Using the Camel API The Camel connector is based on the Reactive Streams support from Camel. If you have an application already using the Camel API (routes, from ...), you can integrate it with Reactive Messaging. Getting the CamelReactiveStreamsService Once you add the Camel connector to your application, you can retrieve the org.apache.camel.component.reactive.streams.api.CamelReactiveStreamsService object: 1 2 @Inject CamelReactiveStreamsService reactiveStreamsService ; This CamelReactiveStreamsService lets you create Publisher and Subscriber instances from existing routes. Using Camel Route with @Outgoing If you have an existing Camel route, you can transform it as a Publisher using the CamelReactiveStreamsService . Then, you can return this Publisher from a method annotated with @Outgoing : 1 2 3 4 @Outgoing ( \"camel\" ) public Publisher < Exchange > retrieveDataFromCamelRoute () { return reactiveStreamsService . from ( \"seda:camel\" ); } You can also use RouteBuilder : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @ApplicationScoped static class MyRouteBuilder extends RouteBuilder { @Inject CamelReactiveStreamsService reactiveStreamsService ; @Outgoing ( \"sink\" ) public Publisher < String > getDataFromCamelRoute () { return reactiveStreamsService . fromStream ( \"my-stream\" , String . class ); } @Override public void configure () { from ( \"seda:camel\" ). process ( exchange -> exchange . getMessage (). setBody ( exchange . getIn (). getBody ( String . class ). toUpperCase ())) . to ( \"reactive-streams:my-stream\" ); } } Using Camel Route with @Incoming If you have an existing Camel route, you can transform it as a Subscriber using the CamelReactiveStreamsService . Then, you can return this Subscriber from a method annotated with @Incoming : 1 2 3 4 5 @Incoming ( \"to-camel\" ) public Subscriber < String > sendDataToCamelRoute () { return reactiveStreamsService . subscriber ( \"file:./target?fileName=values.txt&fileExist=append\" , String . class ); } You can also use a producer: 1 2 3 4 5 6 7 8 @Inject CamelContext camel ; @Incoming ( \"to-camel\" ) public CompletionStage < Void > sink ( String value ) { return camel . createProducerTemplate () . asyncSendBody ( \"file:./target?fileName=values.txt&fileExist=append\" , value ). thenApply ( x -> null ); }","title":"Using existing Camel routes"},{"location":"camel/using-existing-routes/#using-the-camel-api","text":"The Camel connector is based on the Reactive Streams support from Camel. If you have an application already using the Camel API (routes, from ...), you can integrate it with Reactive Messaging.","title":"Using the Camel API"},{"location":"camel/using-existing-routes/#getting-the-camelreactivestreamsservice","text":"Once you add the Camel connector to your application, you can retrieve the org.apache.camel.component.reactive.streams.api.CamelReactiveStreamsService object: 1 2 @Inject CamelReactiveStreamsService reactiveStreamsService ; This CamelReactiveStreamsService lets you create Publisher and Subscriber instances from existing routes.","title":"Getting the CamelReactiveStreamsService"},{"location":"camel/using-existing-routes/#using-camel-route-with-outgoing","text":"If you have an existing Camel route, you can transform it as a Publisher using the CamelReactiveStreamsService . Then, you can return this Publisher from a method annotated with @Outgoing : 1 2 3 4 @Outgoing ( \"camel\" ) public Publisher < Exchange > retrieveDataFromCamelRoute () { return reactiveStreamsService . from ( \"seda:camel\" ); } You can also use RouteBuilder : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @ApplicationScoped static class MyRouteBuilder extends RouteBuilder { @Inject CamelReactiveStreamsService reactiveStreamsService ; @Outgoing ( \"sink\" ) public Publisher < String > getDataFromCamelRoute () { return reactiveStreamsService . fromStream ( \"my-stream\" , String . class ); } @Override public void configure () { from ( \"seda:camel\" ). process ( exchange -> exchange . getMessage (). setBody ( exchange . getIn (). getBody ( String . class ). toUpperCase ())) . to ( \"reactive-streams:my-stream\" ); } }","title":"Using Camel Route with @Outgoing"},{"location":"camel/using-existing-routes/#using-camel-route-with-incoming","text":"If you have an existing Camel route, you can transform it as a Subscriber using the CamelReactiveStreamsService . Then, you can return this Subscriber from a method annotated with @Incoming : 1 2 3 4 5 @Incoming ( \"to-camel\" ) public Subscriber < String > sendDataToCamelRoute () { return reactiveStreamsService . subscriber ( \"file:./target?fileName=values.txt&fileExist=append\" , String . class ); } You can also use a producer: 1 2 3 4 5 6 7 8 @Inject CamelContext camel ; @Incoming ( \"to-camel\" ) public CompletionStage < Void > sink ( String value ) { return camel . createProducerTemplate () . asyncSendBody ( \"file:./target?fileName=values.txt&fileExist=append\" , value ). thenApply ( x -> null ); }","title":"Using Camel Route with @Incoming"},{"location":"concepts/acknowledgement/","text":"Acknowledgement Acknowledgment is an essential concept in messaging. A message is acknowledged when its processing or reception has been successful. It allows the broker to move to the next message. How acknowledgment is used, and the exact behavior in terms of retry and resilience depends on the broker. For example, for Kafka, it would commit the offset. For AMQP, it would inform the broker that the message has been accepted . Reactive Messaging supports acknowledgement. The default acknowledgement depends on the method signature. Also, the acknowledgement policy can be configured using the @Acknowledgement annotation. Chain of acknowledgment If we reuse this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Outgoing ( \"source\" ) public Multi < String > generate () { return Multi . createFrom (). items ( \"Hello\" , \"from\" , \"reactive\" , \"messaging\" ); } @Incoming ( \"source\" ) @Outgoing ( \"sink\" ) public String process ( String in ) { return in . toUpperCase (); } @Incoming ( \"sink\" ) public void consume ( String processed ) { System . out . println ( processed ); } The framework automatically acknowledges the message received from the sink channel when the consume method returns. As a consequence, the message received by the process method is acknowledged, and so on. In other words, it creates a chain of acknowledgement - from the outbound channel to the inbound channel. When using connectors to receive and consume messages, the outbound connector acknowledges the messages when they are dispatched successfully to the broker. The acknowledgment chain would, as a result, acknowledges the inbound connector, which would be able to send an acknowledgment to the broker. This chain of acknowledgment is automatically implemented when processing payloads. Acknowledgment when using Messages When using Messages , the user controls the acknowledgment, and so the chain is not formed automatically. It gives you more flexibility about when and how the incoming messages are acknowledged. If you create a Message using the with method, is copy the acknowledgment function from the incoming message: 1 2 3 4 5 6 7 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Message < Integer > process ( Message < Integer > in ) { // The acknowledgement is forwarded, when the consumer // acknowledges the message, `in` will be acknowledged return in . withPayload ( in . getPayload () + 1 ); } To have more control over the acknowledgment, you can create a brand new Message and pass the acknowledgment function: 1 2 3 4 5 6 7 8 9 10 Message < String > message = Message . of ( \"hello\" , () -> { // called when the consumer acknowledges the message // return a CompletionStage completed when the // acknowledgment of the created message is // completed. // For immediate ack use: return CompletableFuture . completedFuture ( null ); }); However, you may need to create the acknowledgment chain, to acknowledge the incoming message: 1 2 3 4 5 6 7 8 9 10 11 12 13 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Message < Integer > processAndProduceNewMessage ( Message < Integer > in ) { // The acknowledgement is forwarded, when the consumer // acknowledges the message, `in` will be acknowledged return Message . of ( in . getPayload () + 1 , () -> { // Called when the consumer acknowledges the message // ... // Don't forget to acknowledge the incoming message: return in . ack (); }); } To trigger the acknowledgment of the incoming message, use the ack() method. It returns a CompletionStage , receiving null as value when the acknowledgment has completed. Acknowledgment when using streams When transforming streams of Message , the acknowledgment is delegated to the user. It means that it\u2019s up to the user to acknowledge the incoming messages: 1 2 3 4 5 6 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Publisher < Message < String >> transform ( Multi < Message < String >> stream ) { return stream . map ( message -> message . withPayload ( message . getPayload (). toUpperCase ())); } In the previous example, we only generate a single message per incoming message so that we can use the with method. It becomes more sophisticated when grouping incoming messages or when each incoming message produces multiple messages. In the case of a stream of payloads, the default strategy acknowledges the incoming messages before being processed by the method (regardless of the outcome). 1 2 3 4 5 6 7 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Publisher < String > transformPayload ( Multi < String > stream ) { return stream // The incoming messages are already acknowledged . map ( String :: toUpperCase ); } Controlling acknowledgement The Acknowledgment annotation lets you customize the default strategy presented in the previous sections. The @Acknowledgement annotation takes a strategy as parameter. Reactive Messaging proposed 4 strategies: POST_PROCESSING - the acknowledgement of the incoming message is executed once the produced message is acknowledged. PRE_PROCESSING - the acknowledgement of the incoming message is executed before the message is processed by the method. MANUAL - the acknowledgement is doe by the user. NONE - No acknowledgment is performed, neither manually or automatically. It is recommended to use POST_PROCESSING as it guarantees that the full processing has completed before acknowledging the incoming message. However, sometimes it\u2019s not possible, and this strategy is not available if you manipulate streams of Messages or payloads. The PRE_PROCESSING strategy can be useful to acknowledge a message early in the process: 1 2 3 4 5 6 7 8 9 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) @Acknowledgment ( Acknowledgment . Strategy . PRE_PROCESSING ) public String process ( String input ) { // The message wrapping the payload is already acknowledged // The default would have waited the produced message to be // acknowledged return input . toUpperCase (); } It cuts the acknowledgment chain, meaning that the rest of the processing is not linked to the incoming message anymore. This strategy is the default strategy when manipulating streams of payloads. Refer to the signature list to determine which strategies are available for a specific method signature and what\u2019s the default strategy. Negative acknowledgement Messages can also be nacked , which indicates that the message was not processed correctly. The Message.nack method indicates failing processing (and supply the reason), and, as for successful acknowledgment, the nack is propagated through the chain of messages. If the message has been produced by a connector, this connector implements specific behavior when receiving a nack . It can fail (default), or ignore the failing, or implement a dead-letter queue mechanism. Refer to the connector documentation for further details about the available strategies. If the message is sent by an emitter using the send(P) method, the returned CompletionStage is completed exceptionally with the nack reason. 1 2 3 4 5 6 7 8 9 10 11 12 @Inject @Channel ( \"data\" ) Emitter < String > emitter ; public void emitPayload () { CompletionStage < Void > completionStage = emitter . send ( \"hello\" ); completionStage . whenComplete (( acked , nacked ) -> { if ( nacked != null ) { // the processing has failed } }); } Negative acknowledgment can be manual or automatic. If your method handles instances of Message and the acknowledgment strategy is MANUAL , you can nack a message explicitly. You must indicate the reason (an exception) when calling the nack method. As for successful acknowledgment, the nack returns a CompletionStage completed when the nack has been processed. If your method uses the POST_PROCESSING acknowledgment strategy, and the method fails (either by throwing an exception or by producing a failure), the message is automatically nacked with the caught exception: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Incoming ( \"data\" ) @Outgoing ( \"out\" ) public String process ( String s ) { if ( s . equalsIgnoreCase ( \"b\" )) { // Throwing an exception triggers a nack throw new IllegalArgumentException ( \"b\" ); } if ( s . equalsIgnoreCase ( \"e\" )) { // Returning null would skip the message (it will be acked) return null ; } return s . toUpperCase (); } @Incoming ( \"data\" ) @Outgoing ( \"out\" ) public Uni < String > processAsync ( String s ) { if ( s . equalsIgnoreCase ( \"a\" )) { // Returning a failing Uni triggers a nack return Uni . createFrom (). failure ( new Exception ( \"a\" )); } if ( s . equalsIgnoreCase ( \"b\" )) { // Throwing an exception triggers a nack throw new IllegalArgumentException ( \"b\" ); } if ( s . equalsIgnoreCase ( \"e\" )) { // Returning null would skip the message (it will be acked not nacked) return Uni . createFrom (). nullItem (); } if ( s . equalsIgnoreCase ( \"f\" )) { // returning `null` is invalid for method returning Unis, the message is nacked return null ; } return Uni . createFrom (). item ( s . toUpperCase ()); }","title":"Acknowledgement"},{"location":"concepts/acknowledgement/#acknowledgement","text":"Acknowledgment is an essential concept in messaging. A message is acknowledged when its processing or reception has been successful. It allows the broker to move to the next message. How acknowledgment is used, and the exact behavior in terms of retry and resilience depends on the broker. For example, for Kafka, it would commit the offset. For AMQP, it would inform the broker that the message has been accepted . Reactive Messaging supports acknowledgement. The default acknowledgement depends on the method signature. Also, the acknowledgement policy can be configured using the @Acknowledgement annotation.","title":"Acknowledgement"},{"location":"concepts/acknowledgement/#chain-of-acknowledgment","text":"If we reuse this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Outgoing ( \"source\" ) public Multi < String > generate () { return Multi . createFrom (). items ( \"Hello\" , \"from\" , \"reactive\" , \"messaging\" ); } @Incoming ( \"source\" ) @Outgoing ( \"sink\" ) public String process ( String in ) { return in . toUpperCase (); } @Incoming ( \"sink\" ) public void consume ( String processed ) { System . out . println ( processed ); } The framework automatically acknowledges the message received from the sink channel when the consume method returns. As a consequence, the message received by the process method is acknowledged, and so on. In other words, it creates a chain of acknowledgement - from the outbound channel to the inbound channel. When using connectors to receive and consume messages, the outbound connector acknowledges the messages when they are dispatched successfully to the broker. The acknowledgment chain would, as a result, acknowledges the inbound connector, which would be able to send an acknowledgment to the broker. This chain of acknowledgment is automatically implemented when processing payloads.","title":"Chain of acknowledgment"},{"location":"concepts/acknowledgement/#acknowledgment-when-using-messages","text":"When using Messages , the user controls the acknowledgment, and so the chain is not formed automatically. It gives you more flexibility about when and how the incoming messages are acknowledged. If you create a Message using the with method, is copy the acknowledgment function from the incoming message: 1 2 3 4 5 6 7 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Message < Integer > process ( Message < Integer > in ) { // The acknowledgement is forwarded, when the consumer // acknowledges the message, `in` will be acknowledged return in . withPayload ( in . getPayload () + 1 ); } To have more control over the acknowledgment, you can create a brand new Message and pass the acknowledgment function: 1 2 3 4 5 6 7 8 9 10 Message < String > message = Message . of ( \"hello\" , () -> { // called when the consumer acknowledges the message // return a CompletionStage completed when the // acknowledgment of the created message is // completed. // For immediate ack use: return CompletableFuture . completedFuture ( null ); }); However, you may need to create the acknowledgment chain, to acknowledge the incoming message: 1 2 3 4 5 6 7 8 9 10 11 12 13 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Message < Integer > processAndProduceNewMessage ( Message < Integer > in ) { // The acknowledgement is forwarded, when the consumer // acknowledges the message, `in` will be acknowledged return Message . of ( in . getPayload () + 1 , () -> { // Called when the consumer acknowledges the message // ... // Don't forget to acknowledge the incoming message: return in . ack (); }); } To trigger the acknowledgment of the incoming message, use the ack() method. It returns a CompletionStage , receiving null as value when the acknowledgment has completed.","title":"Acknowledgment when using Messages"},{"location":"concepts/acknowledgement/#acknowledgment-when-using-streams","text":"When transforming streams of Message , the acknowledgment is delegated to the user. It means that it\u2019s up to the user to acknowledge the incoming messages: 1 2 3 4 5 6 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Publisher < Message < String >> transform ( Multi < Message < String >> stream ) { return stream . map ( message -> message . withPayload ( message . getPayload (). toUpperCase ())); } In the previous example, we only generate a single message per incoming message so that we can use the with method. It becomes more sophisticated when grouping incoming messages or when each incoming message produces multiple messages. In the case of a stream of payloads, the default strategy acknowledges the incoming messages before being processed by the method (regardless of the outcome). 1 2 3 4 5 6 7 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Publisher < String > transformPayload ( Multi < String > stream ) { return stream // The incoming messages are already acknowledged . map ( String :: toUpperCase ); }","title":"Acknowledgment when using streams"},{"location":"concepts/acknowledgement/#controlling-acknowledgement","text":"The Acknowledgment annotation lets you customize the default strategy presented in the previous sections. The @Acknowledgement annotation takes a strategy as parameter. Reactive Messaging proposed 4 strategies: POST_PROCESSING - the acknowledgement of the incoming message is executed once the produced message is acknowledged. PRE_PROCESSING - the acknowledgement of the incoming message is executed before the message is processed by the method. MANUAL - the acknowledgement is doe by the user. NONE - No acknowledgment is performed, neither manually or automatically. It is recommended to use POST_PROCESSING as it guarantees that the full processing has completed before acknowledging the incoming message. However, sometimes it\u2019s not possible, and this strategy is not available if you manipulate streams of Messages or payloads. The PRE_PROCESSING strategy can be useful to acknowledge a message early in the process: 1 2 3 4 5 6 7 8 9 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) @Acknowledgment ( Acknowledgment . Strategy . PRE_PROCESSING ) public String process ( String input ) { // The message wrapping the payload is already acknowledged // The default would have waited the produced message to be // acknowledged return input . toUpperCase (); } It cuts the acknowledgment chain, meaning that the rest of the processing is not linked to the incoming message anymore. This strategy is the default strategy when manipulating streams of payloads. Refer to the signature list to determine which strategies are available for a specific method signature and what\u2019s the default strategy.","title":"Controlling acknowledgement"},{"location":"concepts/acknowledgement/#negative-acknowledgement","text":"Messages can also be nacked , which indicates that the message was not processed correctly. The Message.nack method indicates failing processing (and supply the reason), and, as for successful acknowledgment, the nack is propagated through the chain of messages. If the message has been produced by a connector, this connector implements specific behavior when receiving a nack . It can fail (default), or ignore the failing, or implement a dead-letter queue mechanism. Refer to the connector documentation for further details about the available strategies. If the message is sent by an emitter using the send(P) method, the returned CompletionStage is completed exceptionally with the nack reason. 1 2 3 4 5 6 7 8 9 10 11 12 @Inject @Channel ( \"data\" ) Emitter < String > emitter ; public void emitPayload () { CompletionStage < Void > completionStage = emitter . send ( \"hello\" ); completionStage . whenComplete (( acked , nacked ) -> { if ( nacked != null ) { // the processing has failed } }); } Negative acknowledgment can be manual or automatic. If your method handles instances of Message and the acknowledgment strategy is MANUAL , you can nack a message explicitly. You must indicate the reason (an exception) when calling the nack method. As for successful acknowledgment, the nack returns a CompletionStage completed when the nack has been processed. If your method uses the POST_PROCESSING acknowledgment strategy, and the method fails (either by throwing an exception or by producing a failure), the message is automatically nacked with the caught exception: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Incoming ( \"data\" ) @Outgoing ( \"out\" ) public String process ( String s ) { if ( s . equalsIgnoreCase ( \"b\" )) { // Throwing an exception triggers a nack throw new IllegalArgumentException ( \"b\" ); } if ( s . equalsIgnoreCase ( \"e\" )) { // Returning null would skip the message (it will be acked) return null ; } return s . toUpperCase (); } @Incoming ( \"data\" ) @Outgoing ( \"out\" ) public Uni < String > processAsync ( String s ) { if ( s . equalsIgnoreCase ( \"a\" )) { // Returning a failing Uni triggers a nack return Uni . createFrom (). failure ( new Exception ( \"a\" )); } if ( s . equalsIgnoreCase ( \"b\" )) { // Throwing an exception triggers a nack throw new IllegalArgumentException ( \"b\" ); } if ( s . equalsIgnoreCase ( \"e\" )) { // Returning null would skip the message (it will be acked not nacked) return Uni . createFrom (). nullItem (); } if ( s . equalsIgnoreCase ( \"f\" )) { // returning `null` is invalid for method returning Unis, the message is nacked return null ; } return Uni . createFrom (). item ( s . toUpperCase ()); }","title":"Negative acknowledgement"},{"location":"concepts/advanced-config/","text":"Advanced configuration Strict Binding Mode By default, SmallRye Reactive Messaging does not enforce whether all mediators are connected. It just prints a warning message. The strict mode fails the deployment if some \"incomings\" are not bound to \"outgoings\". To enable this mode, you can pass the -Dsmallrye-messaging-strict-binding=true via the command line, or you can set the smallrye-messaging-strict-binding attribute to true in the configuration: 1 smallrye-messaging-strict-binding=true Disabling channels You can disable a channel in the configuration by setting the enabled attribute to false : 1 2 mp.messaging.outgoing.dummy-sink.connector=dummy mp.messaging.outgoing.dummy-sink.enabled=false # Disable this channel SmallRye Reactive Messaging does not register disabled channels, so make sure the rest of the application does not rely on them. Publisher metrics SmallRye Reactive Messaging integrates MicroProfile Metrics and Micrometer for registering counter metrics (named mp.messaging.message.count ) of published messages per channel. Both MicroProfile and Micrometer publisher metrics are enabled by default if found on the classpath. They can be disabled with smallrye.messaging.metrics.mp.enabled and smallrye.messaging.metrics.micrometer.enabled properties respectively.","title":"Advanced Configuration"},{"location":"concepts/advanced-config/#advanced-configuration","text":"","title":"Advanced configuration"},{"location":"concepts/advanced-config/#strict-binding-mode","text":"By default, SmallRye Reactive Messaging does not enforce whether all mediators are connected. It just prints a warning message. The strict mode fails the deployment if some \"incomings\" are not bound to \"outgoings\". To enable this mode, you can pass the -Dsmallrye-messaging-strict-binding=true via the command line, or you can set the smallrye-messaging-strict-binding attribute to true in the configuration: 1 smallrye-messaging-strict-binding=true","title":"Strict Binding Mode"},{"location":"concepts/advanced-config/#disabling-channels","text":"You can disable a channel in the configuration by setting the enabled attribute to false : 1 2 mp.messaging.outgoing.dummy-sink.connector=dummy mp.messaging.outgoing.dummy-sink.enabled=false # Disable this channel SmallRye Reactive Messaging does not register disabled channels, so make sure the rest of the application does not rely on them.","title":"Disabling channels"},{"location":"concepts/advanced-config/#publisher-metrics","text":"SmallRye Reactive Messaging integrates MicroProfile Metrics and Micrometer for registering counter metrics (named mp.messaging.message.count ) of published messages per channel. Both MicroProfile and Micrometer publisher metrics are enabled by default if found on the classpath. They can be disabled with smallrye.messaging.metrics.mp.enabled and smallrye.messaging.metrics.micrometer.enabled properties respectively.","title":"Publisher metrics"},{"location":"concepts/blocking/","text":"@Blocking The io.smallrye.reactive.messaging.annotations.Blocking annotation can be used on a method annotated with @Incoming , or @Outgoing to indicate that the method should be executed on a worker pool: 1 2 3 4 5 6 @Outgoing ( \"Y\" ) @Incoming ( \"X\" ) @Blocking public String process ( String s ) { return s . toUpperCase (); } If method execution does not need to be ordered, it can be indicated on the @Blocking annotation: 1 2 3 4 5 6 @Outgoing ( \"Y\" ) @Incoming ( \"X\" ) @Blocking ( ordered = false ) public String process ( String s ) { return s . toUpperCase (); } When unordered, the invocation can happen concurrently. By default, use of @Blocking results in the method being executed in the Vert.x worker pool. If it\u2019s desired to execute methods on a custom worker pool, with specific concurrency needs, it can be defined on @Blocking : 1 2 3 4 5 6 @Outgoing ( \"Y\" ) @Incoming ( \"X\" ) @Blocking ( \"my-custom-pool\" ) public String process ( String s ) { return s . toUpperCase (); } Specifying the concurrency for the above worker pool requires the following configuration property to be defined: 1 smallrye.messaging.worker.my-custom-pool.max-concurrency=3 Supported signatures @Blocking does not support every signature. The following table lists the supported ones. Shape Signature Comment Publisher @Outgoing(\"in\") @Blocking O generator() Invokes the generator from a worker thread. If ordered is set to false , the generator can be called concurrently. Publisher @Outgoing(\"in\") @Blocking Message<O> generator() Invokes the generator from a worker thread. If ordered is set to false , the generator can be called concurrently. Processor @Incoming(\"in\") @Outgoing(\"bar\") @Blocking O process(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. Processor @Incoming(\"in\") @Outgoing(\"bar\") @Blocking Message<O> process(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. Subscriber @Incoming(\"in\") @Blocking void consume(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. Subscriber @Incoming(\"in\") @Blocking Uni<Void> consume(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. Subscriber @Incoming(\"in\") @Blocking CompletionStage<Void> consume(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. When a method can be called concurrently, the max concurrency depends on the number of threads from the worker thread pool. Using io.smallrye.common.annotation.Blocking io.smallrye.common.annotation.Blocking is another annotation with the same semantic. io.smallrye.common.annotation.Blocking is used by multiple SmallRye projects and Quarkus. SmallRye Reactive Messaging also supports io.smallrye.common.annotation.Blocking . However, io.smallrye.common.annotation.Blocking does not allow configuring the ordering (it defaults to ordered=true ). When both annotations are used, io.smallrye.reactive.messaging.annotations.Blocking is preferred.","title":"Blocking Processing"},{"location":"concepts/blocking/#blocking","text":"The io.smallrye.reactive.messaging.annotations.Blocking annotation can be used on a method annotated with @Incoming , or @Outgoing to indicate that the method should be executed on a worker pool: 1 2 3 4 5 6 @Outgoing ( \"Y\" ) @Incoming ( \"X\" ) @Blocking public String process ( String s ) { return s . toUpperCase (); } If method execution does not need to be ordered, it can be indicated on the @Blocking annotation: 1 2 3 4 5 6 @Outgoing ( \"Y\" ) @Incoming ( \"X\" ) @Blocking ( ordered = false ) public String process ( String s ) { return s . toUpperCase (); } When unordered, the invocation can happen concurrently. By default, use of @Blocking results in the method being executed in the Vert.x worker pool. If it\u2019s desired to execute methods on a custom worker pool, with specific concurrency needs, it can be defined on @Blocking : 1 2 3 4 5 6 @Outgoing ( \"Y\" ) @Incoming ( \"X\" ) @Blocking ( \"my-custom-pool\" ) public String process ( String s ) { return s . toUpperCase (); } Specifying the concurrency for the above worker pool requires the following configuration property to be defined: 1 smallrye.messaging.worker.my-custom-pool.max-concurrency=3","title":"@Blocking"},{"location":"concepts/blocking/#supported-signatures","text":"@Blocking does not support every signature. The following table lists the supported ones. Shape Signature Comment Publisher @Outgoing(\"in\") @Blocking O generator() Invokes the generator from a worker thread. If ordered is set to false , the generator can be called concurrently. Publisher @Outgoing(\"in\") @Blocking Message<O> generator() Invokes the generator from a worker thread. If ordered is set to false , the generator can be called concurrently. Processor @Incoming(\"in\") @Outgoing(\"bar\") @Blocking O process(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. Processor @Incoming(\"in\") @Outgoing(\"bar\") @Blocking Message<O> process(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. Subscriber @Incoming(\"in\") @Blocking void consume(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. Subscriber @Incoming(\"in\") @Blocking Uni<Void> consume(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. Subscriber @Incoming(\"in\") @Blocking CompletionStage<Void> consume(I in) Invokes the method on a worker thread. If ordered is set to false , the method can be called concurrently. When a method can be called concurrently, the max concurrency depends on the number of threads from the worker thread pool.","title":"Supported signatures"},{"location":"concepts/blocking/#using-iosmallryecommonannotationblocking","text":"io.smallrye.common.annotation.Blocking is another annotation with the same semantic. io.smallrye.common.annotation.Blocking is used by multiple SmallRye projects and Quarkus. SmallRye Reactive Messaging also supports io.smallrye.common.annotation.Blocking . However, io.smallrye.common.annotation.Blocking does not allow configuring the ordering (it defaults to ordered=true ). When both annotations are used, io.smallrye.reactive.messaging.annotations.Blocking is preferred.","title":"Using io.smallrye.common.annotation.Blocking"},{"location":"concepts/broadcast/","text":"Broadcast Experimental @Broadcast is an experimental feature. By default, messages transiting in a channel are only dispatched to a single consumer. Having multiple consumers is considered as an error, and is reported at deployment time. The Broadcast annotation changes this behavior and indicates that messages transiting in the channel are dispatched to all the consumers. @Broadcast must be used with the @Outgoing annotation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) @Broadcast public int increment ( int i ) { return i + 1 ; } @Incoming ( \"out\" ) public void consume1 ( int i ) { //... } @Incoming ( \"out\" ) public void consume2 ( int i ) { //... } In the previous example, both consumers get the messages. You can also control the number of consumers to wait before starting to dispatch the messages. This allows waiting for the complete graph to be woven: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) @Broadcast ( 2 ) public int increment ( int i ) { return i + 1 ; } @Incoming ( \"out\" ) public void consume1 ( int i ) { //... } @Incoming ( \"out\" ) public void consume2 ( int i ) { //... } Note Inbound connectors also support a broadcast attribute that allows broadcasting the messages to multiple downstream subscribers. Use with Emitter For details on how to use @Broadcast with Emitter see the documentation .","title":"Broadcast"},{"location":"concepts/broadcast/#broadcast","text":"Experimental @Broadcast is an experimental feature. By default, messages transiting in a channel are only dispatched to a single consumer. Having multiple consumers is considered as an error, and is reported at deployment time. The Broadcast annotation changes this behavior and indicates that messages transiting in the channel are dispatched to all the consumers. @Broadcast must be used with the @Outgoing annotation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) @Broadcast public int increment ( int i ) { return i + 1 ; } @Incoming ( \"out\" ) public void consume1 ( int i ) { //... } @Incoming ( \"out\" ) public void consume2 ( int i ) { //... } In the previous example, both consumers get the messages. You can also control the number of consumers to wait before starting to dispatch the messages. This allows waiting for the complete graph to be woven: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) @Broadcast ( 2 ) public int increment ( int i ) { return i + 1 ; } @Incoming ( \"out\" ) public void consume1 ( int i ) { //... } @Incoming ( \"out\" ) public void consume2 ( int i ) { //... } Note Inbound connectors also support a broadcast attribute that allows broadcasting the messages to multiple downstream subscribers.","title":"Broadcast"},{"location":"concepts/broadcast/#use-with-emitter","text":"For details on how to use @Broadcast with Emitter see the documentation .","title":"Use with Emitter"},{"location":"concepts/concepts/","text":"When dealing with event-driven or data streaming applications, there are a few concepts and vocabulary to introduce. Concepts Messages, Payload, Metadata A Message is an envelope around a payload . Your application is going to receive, process, and send Messages . Your application\u2019s logic can generate these Messages or receive them from a message broker. They can also be consumed by your application or sent to a message broker. An application can receive a message, process it and send a resulting message In Reactive Messaging, Message are represented by the Message interface. Each Message<T> contains a payload of type <T> . This payload can be retrieved using message.getPayload() : 1 2 String payload = message . getPayload (); Optional < MyMetadata > metadata = message . getMetadata ( MyMetadata . class ); As you can see in the previous snippet, Messages can also have metadata . Metadata is a way to extend messages with additional data. It can be metadata related to the message broker (like KafkaMessageMetadata ), or contain operational data (such as tracing metadata), or business-related data. Note When retrieving metadata, you get an Optional as it may not be present. Tip Metadata is also used to influence the outbound dispatching (how the message will be sent to the broker). Channels and Streams Inside your application, Messages transit on channel . A channel is a virtual destination identified by a name. The application is a set of channels SmallRye Reactive Messaging connects the component to the channel they read and to the channel they populate. The resulting structure is a stream: Messages flow between components through channels. What about Reactive Streams? You may wonder why Reactive Messaging has Reactive in the name. The Messaging part is kind of obvious. The Reactive part comes from the streams that are created by binding components. These streams are Reactive Streams . They follow the subscription and request protocol and implement back-pressure. It also means that Connectors are intended to use non-blocking IO to interact with the various message brokers. Connectors Your application is interacting with messaging brokers or event backbone using connectors . A connector is a piece of code that connects to a broker and: subscribe/poll/receive messages from the broker and propagate them to the application send/write/dispatch messages provided by the application to the broker Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel. These collected messages are sent to the external broker. Connectors manages the communication between the application and the brokers Each connector is dedicated to a specific technology. For example, a Kafka Connector only deals with Kafka. You don\u2019t necessarily need a connector. When your application does not use connectors, everything happens in-memory , and the streams are created by chaining methods altogether. Each chain is still a reactive stream and enforces the back-pressure protocol. When you don\u2019t use connectors, you need to make sure the chain is complete, meaning it starts with a message source, and it ends with a sink. In other words, you need to generate messages from within the application (using a method with only @Outgoing , or an Emitter ) and consume the messages from within the application (using a method with only @Incoming or using an unmanaged stream).","title":"Concepts"},{"location":"concepts/concepts/#concepts","text":"","title":"Concepts"},{"location":"concepts/concepts/#messages-payload-metadata","text":"A Message is an envelope around a payload . Your application is going to receive, process, and send Messages . Your application\u2019s logic can generate these Messages or receive them from a message broker. They can also be consumed by your application or sent to a message broker. An application can receive a message, process it and send a resulting message In Reactive Messaging, Message are represented by the Message interface. Each Message<T> contains a payload of type <T> . This payload can be retrieved using message.getPayload() : 1 2 String payload = message . getPayload (); Optional < MyMetadata > metadata = message . getMetadata ( MyMetadata . class ); As you can see in the previous snippet, Messages can also have metadata . Metadata is a way to extend messages with additional data. It can be metadata related to the message broker (like KafkaMessageMetadata ), or contain operational data (such as tracing metadata), or business-related data. Note When retrieving metadata, you get an Optional as it may not be present. Tip Metadata is also used to influence the outbound dispatching (how the message will be sent to the broker).","title":"Messages, Payload, Metadata"},{"location":"concepts/concepts/#channels-and-streams","text":"Inside your application, Messages transit on channel . A channel is a virtual destination identified by a name. The application is a set of channels SmallRye Reactive Messaging connects the component to the channel they read and to the channel they populate. The resulting structure is a stream: Messages flow between components through channels. What about Reactive Streams? You may wonder why Reactive Messaging has Reactive in the name. The Messaging part is kind of obvious. The Reactive part comes from the streams that are created by binding components. These streams are Reactive Streams . They follow the subscription and request protocol and implement back-pressure. It also means that Connectors are intended to use non-blocking IO to interact with the various message brokers.","title":"Channels and Streams"},{"location":"concepts/concepts/#connectors","text":"Your application is interacting with messaging brokers or event backbone using connectors . A connector is a piece of code that connects to a broker and: subscribe/poll/receive messages from the broker and propagate them to the application send/write/dispatch messages provided by the application to the broker Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel. These collected messages are sent to the external broker. Connectors manages the communication between the application and the brokers Each connector is dedicated to a specific technology. For example, a Kafka Connector only deals with Kafka. You don\u2019t necessarily need a connector. When your application does not use connectors, everything happens in-memory , and the streams are created by chaining methods altogether. Each chain is still a reactive stream and enforces the back-pressure protocol. When you don\u2019t use connectors, you need to make sure the chain is complete, meaning it starts with a message source, and it ends with a sink. In other words, you need to generate messages from within the application (using a method with only @Outgoing , or an Emitter ) and consume the messages from within the application (using a method with only @Incoming or using an unmanaged stream).","title":"Connectors"},{"location":"concepts/connectors/","text":"Connectors Reactive Messaging can handle messages generated from within the application but also interact with remote brokers . Reactive Messaging Connectors interacts with these remote brokers to retrieve messages and send messages using various protocols and technology. Each connector handles to a specific technology. For example, a Kafka Connector is responsible for interacting with Kafka, while an MQTT Connector is responsible for MQTT interactions. Connector name Each connector has a name. This name is referenced by the application to indicate that this connector manages a specific channel. For example, the SmallRye Kafka Connector is named: smallrye-kafka . Inbound and Outbound connectors Connector can: retrieve messages from a remote broker (inbound) send messages to a remove broker (outbound) A connector can, of course, implement both directions. Inbound connectors are responsible for: Getting messages from the remote broker, Creating a Reactive Messaging Message associated with the retrieved message. Potentially associating technical metadata with the message. It includes unmarshalling the payload. Associating an acknowledgment callback to acknowledge the incoming message when the Reactive Messaging message is processed/acknowledged. Reactive matters The first step should follow the reactive streams principle: uses non-blocking technology, respects downstream requests. Outbound connectors are responsible for: Receiving Reactive Messaging Message and transform it into a structure understood by the remote broker. It includes marshaling the payload. If the Message contains outbound metadata (metadata set during the processing to influence the outbound structure and routing), taking them into account. Sending the message to the remote broker. Acknowledging the Reactive Messaging Message when the broker has accepted/acknowledged the message. Configuring connectors Applications need to configure the connector used by expressing which channel is managed by which connector. Non-mapped channels are local / in-memory. To configure connectors, you need to have an implementation of MicroProfile Config. If you don\u2019t have one, add an implementation of MicroProfile Config in your classpath , such as: 1 2 3 4 5 <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config </artifactId> <version> 2.7.0 </version> </dependency> Then edit the application configuration, generally src/main/resources/META-INF/microprofile-config.properties . The application configures the connector with a set of properties structured as follows: 1 mp.messaging.[incoming|outgoing].[channel-name].[attribute]=[value] For example: 1 2 3 4 mp.messaging.incoming.dummy-incoming-channel.connector=dummy mp.messaging.incoming.dummy-incoming-channel.attribute=value mp.messaging.outgoing.dummy-outgoing-channel.connector=dummy mp.messaging.outgoing.dummy-outgoing-channel.attribute=value You configure each channel (both incoming and outgoing) individually. The [incoming|outgoing] segment indicates the direction. an incoming channel consumes data from a message broker or something producing data. It\u2019s an inbound interaction. It relates to methods annotated with an @Incoming using the same channel name. an outgoing consumes data from the application and forwards it to a message broker or something consuming data. It\u2019s an outbound interaction. It relates to methods annotated with an @Outgoing using the same channel name. The [channel-name] is the name of the channel. If the channel name contains a . (dot), you would need to use \" (double-quote) around it. For example, to configure the dummy.incoming.channel channel, you would need: 1 2 mp.messaging.incoming.\"dummy.incoming.channel\".connector=dummy mp.messaging.incoming.\"dummy.incoming.channel\".attribute=value The [attribute]=[value] sets a specific connector attribute to the given value. Attributes depend on the used connector. So, refer to the connector documentation to check the supported attributes. The connector attribute must be set for each mapped channel and indicates the name of the connector responsible for the channel. Here is an example of a channel using an MQTT connector, consuming data from a MQTT broker, and a channel using a Kafka connector (writing data to Kafka): 1 2 3 4 5 6 7 8 9 10 11 12 # Configure the incoming health channel mp.messaging.incoming.health.topic = neo mp.messaging.incoming.health.connector = smallrye-mqtt mp.messaging.incoming.health.host = localhost mp.messaging.incoming.health.broadcast = true # Configure outgoing data channel mp.messaging.outgoing.data.connector = smallrye-kafka mp.messaging.outgoing.data.bootstrap.servers = localhost:9092 mp.messaging.outgoing.data.key.serializer = org.apache.kafka.common.serialization.StringSerializer mp.messaging.outgoing.data.value.serializer = io.vertx.kafka.client.serialization.JsonObjectSerializer mp.messaging.outgoing.data.acks = 1 Important To use a connector, you need to add it to your CLASSPATH . Generally, adding the dependency to your project is enough. Then, you need to know the connector\u2019s name and set the connector attribute for each channel managed by this connector. Connector attribute table In the connector documentation, you will find a table listing the attribute supported by the connector. Be aware that attributes for inbound and outbound interactions may be different. These tables contain the following entries: The name of the attribute, and potentially an alias . The name of the attribute is used with the mp.messaging.[incoming|outgoing].[channel-name].[attribute]=[value] syntax (the attribute segment). The alias (if set) is the name of a global MicroProfile Config property that avoids having to configure the attribute for each managed channel. For example, to set the location of your Kafka broker globally, you can use the kafka.bootstrap.servers alias. The description of the attribute, including the type. Whether that attribute is mandatory. If so, it fails the deployment if not set The default value, if any.","title":"Connectors"},{"location":"concepts/connectors/#connectors","text":"Reactive Messaging can handle messages generated from within the application but also interact with remote brokers . Reactive Messaging Connectors interacts with these remote brokers to retrieve messages and send messages using various protocols and technology. Each connector handles to a specific technology. For example, a Kafka Connector is responsible for interacting with Kafka, while an MQTT Connector is responsible for MQTT interactions.","title":"Connectors"},{"location":"concepts/connectors/#connector-name","text":"Each connector has a name. This name is referenced by the application to indicate that this connector manages a specific channel. For example, the SmallRye Kafka Connector is named: smallrye-kafka .","title":"Connector name"},{"location":"concepts/connectors/#inbound-and-outbound-connectors","text":"Connector can: retrieve messages from a remote broker (inbound) send messages to a remove broker (outbound) A connector can, of course, implement both directions. Inbound connectors are responsible for: Getting messages from the remote broker, Creating a Reactive Messaging Message associated with the retrieved message. Potentially associating technical metadata with the message. It includes unmarshalling the payload. Associating an acknowledgment callback to acknowledge the incoming message when the Reactive Messaging message is processed/acknowledged. Reactive matters The first step should follow the reactive streams principle: uses non-blocking technology, respects downstream requests. Outbound connectors are responsible for: Receiving Reactive Messaging Message and transform it into a structure understood by the remote broker. It includes marshaling the payload. If the Message contains outbound metadata (metadata set during the processing to influence the outbound structure and routing), taking them into account. Sending the message to the remote broker. Acknowledging the Reactive Messaging Message when the broker has accepted/acknowledged the message.","title":"Inbound and Outbound connectors"},{"location":"concepts/connectors/#configuring-connectors","text":"Applications need to configure the connector used by expressing which channel is managed by which connector. Non-mapped channels are local / in-memory. To configure connectors, you need to have an implementation of MicroProfile Config. If you don\u2019t have one, add an implementation of MicroProfile Config in your classpath , such as: 1 2 3 4 5 <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config </artifactId> <version> 2.7.0 </version> </dependency> Then edit the application configuration, generally src/main/resources/META-INF/microprofile-config.properties . The application configures the connector with a set of properties structured as follows: 1 mp.messaging.[incoming|outgoing].[channel-name].[attribute]=[value] For example: 1 2 3 4 mp.messaging.incoming.dummy-incoming-channel.connector=dummy mp.messaging.incoming.dummy-incoming-channel.attribute=value mp.messaging.outgoing.dummy-outgoing-channel.connector=dummy mp.messaging.outgoing.dummy-outgoing-channel.attribute=value You configure each channel (both incoming and outgoing) individually. The [incoming|outgoing] segment indicates the direction. an incoming channel consumes data from a message broker or something producing data. It\u2019s an inbound interaction. It relates to methods annotated with an @Incoming using the same channel name. an outgoing consumes data from the application and forwards it to a message broker or something consuming data. It\u2019s an outbound interaction. It relates to methods annotated with an @Outgoing using the same channel name. The [channel-name] is the name of the channel. If the channel name contains a . (dot), you would need to use \" (double-quote) around it. For example, to configure the dummy.incoming.channel channel, you would need: 1 2 mp.messaging.incoming.\"dummy.incoming.channel\".connector=dummy mp.messaging.incoming.\"dummy.incoming.channel\".attribute=value The [attribute]=[value] sets a specific connector attribute to the given value. Attributes depend on the used connector. So, refer to the connector documentation to check the supported attributes. The connector attribute must be set for each mapped channel and indicates the name of the connector responsible for the channel. Here is an example of a channel using an MQTT connector, consuming data from a MQTT broker, and a channel using a Kafka connector (writing data to Kafka): 1 2 3 4 5 6 7 8 9 10 11 12 # Configure the incoming health channel mp.messaging.incoming.health.topic = neo mp.messaging.incoming.health.connector = smallrye-mqtt mp.messaging.incoming.health.host = localhost mp.messaging.incoming.health.broadcast = true # Configure outgoing data channel mp.messaging.outgoing.data.connector = smallrye-kafka mp.messaging.outgoing.data.bootstrap.servers = localhost:9092 mp.messaging.outgoing.data.key.serializer = org.apache.kafka.common.serialization.StringSerializer mp.messaging.outgoing.data.value.serializer = io.vertx.kafka.client.serialization.JsonObjectSerializer mp.messaging.outgoing.data.acks = 1 Important To use a connector, you need to add it to your CLASSPATH . Generally, adding the dependency to your project is enough. Then, you need to know the connector\u2019s name and set the connector attribute for each channel managed by this connector.","title":"Configuring connectors"},{"location":"concepts/connectors/#connector-attribute-table","text":"In the connector documentation, you will find a table listing the attribute supported by the connector. Be aware that attributes for inbound and outbound interactions may be different. These tables contain the following entries: The name of the attribute, and potentially an alias . The name of the attribute is used with the mp.messaging.[incoming|outgoing].[channel-name].[attribute]=[value] syntax (the attribute segment). The alias (if set) is the name of a global MicroProfile Config property that avoids having to configure the attribute for each managed channel. For example, to set the location of your Kafka broker globally, you can use the kafka.bootstrap.servers alias. The description of the attribute, including the type. Whether that attribute is mandatory. If so, it fails the deployment if not set The default value, if any.","title":"Connector attribute table"},{"location":"concepts/converters/","text":"Message Converters SmallRye Reactive Messaging supports message converters , allowing to transform an incoming message into a version accepted by the method. If the incoming messages or payload does not match the invoked method\u2019s expectation, SmallRye Reactive Messaging looks for a suitable converter. If found, it converts the incoming message with this converter. Converters can have multiple purposes, but the main use case is about transforming the message\u2019s payload: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @ApplicationScoped public class MyConverter implements MessageConverter { @Override public boolean canConvert ( Message <?> in , Type target ) { // Checks whether this converter can be used to convert // the incoming message into a message containing a payload // of the type `target`. return in . getPayload (). getClass (). equals ( String . class ) && target . equals ( Person . class ); } @Override public Message <?> convert ( Message <?> in , Type target ) { // Convert the incoming message into the new message. // It's important to build the new message **from** // the received one. return in . withPayload ( new Person (( String ) in . getPayload ())); } } To provide a converter, implement a bean exposing the MessageConverter interface. The canConvert method is called during the lookup and verifies if it can handle the conversion. The target type is the expected payload type. If the converter returns true to canConvert , SmallRye Reactive Messaging calls the convert method to proceed to the conversion. The previous converter can be used in application like the following, to convert Message<String> to Message<Person> : 1 2 3 4 5 6 7 8 9 10 11 @Outgoing ( \"persons\" ) public Multi < String > source () { return Multi . createFrom (). items ( \"Neo\" , \"Morpheus\" , \"Trinity\" ); } // The messages need to be converted as they are emitted as Message<String> // and consumed as Message<Person> @Incoming ( \"persons\" ) public void consume ( Person p ) { // ... } Converters work for all supported method signatures. However, the signature must be well-formed to allow the extraction of the expected payload type. Wildcards and raw types do not support conversion. If the expected payload type cannot be extracted, or no converter fits, the message is passed as received. If multiple suitable converters are present, implementations should override the getPriority method returning the priority. The default priority is 100 . The converter lookup invokes converters with higher priority first.","title":"Message Converters"},{"location":"concepts/converters/#message-converters","text":"SmallRye Reactive Messaging supports message converters , allowing to transform an incoming message into a version accepted by the method. If the incoming messages or payload does not match the invoked method\u2019s expectation, SmallRye Reactive Messaging looks for a suitable converter. If found, it converts the incoming message with this converter. Converters can have multiple purposes, but the main use case is about transforming the message\u2019s payload: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @ApplicationScoped public class MyConverter implements MessageConverter { @Override public boolean canConvert ( Message <?> in , Type target ) { // Checks whether this converter can be used to convert // the incoming message into a message containing a payload // of the type `target`. return in . getPayload (). getClass (). equals ( String . class ) && target . equals ( Person . class ); } @Override public Message <?> convert ( Message <?> in , Type target ) { // Convert the incoming message into the new message. // It's important to build the new message **from** // the received one. return in . withPayload ( new Person (( String ) in . getPayload ())); } } To provide a converter, implement a bean exposing the MessageConverter interface. The canConvert method is called during the lookup and verifies if it can handle the conversion. The target type is the expected payload type. If the converter returns true to canConvert , SmallRye Reactive Messaging calls the convert method to proceed to the conversion. The previous converter can be used in application like the following, to convert Message<String> to Message<Person> : 1 2 3 4 5 6 7 8 9 10 11 @Outgoing ( \"persons\" ) public Multi < String > source () { return Multi . createFrom (). items ( \"Neo\" , \"Morpheus\" , \"Trinity\" ); } // The messages need to be converted as they are emitted as Message<String> // and consumed as Message<Person> @Incoming ( \"persons\" ) public void consume ( Person p ) { // ... } Converters work for all supported method signatures. However, the signature must be well-formed to allow the extraction of the expected payload type. Wildcards and raw types do not support conversion. If the expected payload type cannot be extracted, or no converter fits, the message is passed as received. If multiple suitable converters are present, implementations should override the getPriority method returning the priority. The default priority is 100 . The converter lookup invokes converters with higher priority first.","title":"Message Converters"},{"location":"concepts/emitter/","text":"Emitter and Channels It is not rare to combine in a single application imperative parts (Jax-RS, regular CDI beans ) and reactive parts ( beans with @Incoming and @Outgoing annotations). In these case, it\u2019s often required to send messages from the imperative part to the reactive part. In other words, send messages to channels handled by reactive messaging and how can you retrieve messages. Emitter and @Channel To send things (payload or Message ) from imperative code to a specific channel you need to use: the org.eclipse.microprofile.reactive.messaging.Channel annotations the org.eclipse.microprofile.reactive.messaging.Emitter type The @Channel lets you indicate to which channel you are going to send your payloads or messages. The Emitter is the object to use to send these payloads or messages. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.eclipse.microprofile.reactive.messaging.Channel ; import org.eclipse.microprofile.reactive.messaging.Emitter ; @ApplicationScoped public class MyImperativeBean { @Inject @Channel ( \"prices\" ) Emitter < Double > emitter ; // ... public void send ( double d ) { emitter . send ( d ); } } The Emitter class takes a type parameter. It\u2019s the type of payload. Even if you want to send Messages , the type is the payload type. Important You must have a @Incoming(\"prices\") somewhere in your application (meaning a method consuming messages transiting on the channel prices ), or an outbound connector configured to manage the prices channel ( mp.messaging.outgoing.prices... ) Sending payloads Sending payloads is done as follows: 1 2 3 4 5 6 7 @Inject @Channel ( \"prices\" ) Emitter < Double > emitterForPrices ; public void send ( double d ) { emitterForPrices . send ( d ); } When sending a payload, the emitter returns a CompletionStage . This CompletionStage gets completed once the message created from the payload is acknowledged: 1 2 3 4 5 6 public void sendAndAwaitAcknowledgement ( double d ) { CompletionStage < Void > acked = emitterForPrices . send ( d ); // sending a payload returns a CompletionStage completed // when the message is acknowledged acked . toCompletableFuture (). join (); } If the processing fails, the CompletionStage gets completed exceptionally (with the reason of the nack). Sending messages You can also send Messages : 1 2 3 public void sendAsMessage ( double d ) { emitterForPrices . send ( Message . of ( d )); } When sending a Message , the emitter does not return a CompletionStage , but you can pass the ack/nack callback, and be called when the message is acked/nacked. 1 2 3 4 5 6 7 8 9 10 public void sendAsMessageWithAck ( double d ) { emitterForPrices . send ( Message . of ( d , () -> { // Called when the message is acknowledged. return CompletableFuture . completedFuture ( null ); }, reason -> { // Called when the message is acknowledged negatively. return CompletableFuture . completedFuture ( null ); })); } Sending messages also let you pass metadata. 1 2 3 4 5 6 7 8 9 10 11 12 public void sendAsMessageWithAckAndMetadata ( double d ) { MyMetadata metadata = new MyMetadata (); emitterForPrices . send ( Message . of ( d , Metadata . of ( metadata ), () -> { // Called when the message is acknowledged. return CompletableFuture . completedFuture ( null ); }, reason -> { // Called when the message is acknowledged negatively. return CompletableFuture . completedFuture ( null ); })); } Metadata can be used to propagate some context objects with the message. Overflow management When sending messages from imperative code to reactive code, you must be aware of back-pressure. Indeed, messages sent using the emitter and stored in a queue . If the consumer does not process the messages quickly enough, this queue can become a memory hog and you may even run out of memory. To control what need to happen when the queue becomes out of control, use the OnOverflow annotation. @OnOverflow lets you configure: the maximum size of the queue (default is 256) what needs to happen when this size is reached (fail, drop...) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Set the max size to 10 and fail if reached @OnOverflow ( value = OnOverflow . Strategy . BUFFER , bufferSize = 10 ) @Inject @Channel ( \"channel\" ) Emitter < String > emitterWithBuffer ; // [DANGER ZONE] no limit @OnOverflow ( OnOverflow . Strategy . UNBOUNDED_BUFFER ) @Inject @Channel ( \"channel\" ) Emitter < String > danger ; // Drop the new messages if the size is reached @OnOverflow ( OnOverflow . Strategy . DROP ) @Inject @Channel ( \"channel\" ) Emitter < String > dropping ; // Drop the previously sent messages if the size is reached @OnOverflow ( OnOverflow . Strategy . LATEST ) @Inject @Channel ( \"channel\" ) Emitter < String > dropOldMessages ; The supported strategies are: OnOverflow.Strategy.BUFFER - use a buffer to store the elements until they are consumed. If the buffer is full, a failure is propagated (and the thread using the emitted gets an exception) OnOverflow.Strategy.UNBOUNDED_BUFFER - use an unbounded buffer to store the elements OnOverflow.Strategy.DROP - drops the most recent value if the downstream can\u2019t keep up. It means that new value emitted by the emitter are ignored. OnOverflow.Strategy.FAIL - propagates a failure in case the downstream can\u2019t keep up. OnOverflow.Strategy.LATEST - keeps only the latest value, dropping any previous value if the downstream can\u2019t keep up. OnOverflow.Strategy.NONE - ignore the back-pressure signals letting the downstream consumer to implement a strategy. Defensive emission Having an emitter injected into your code does not guarantee that someone is ready to consume the message. For example, a subscriber may be connecting to a remote broker. If there are no subscribers, using the send method will throw an exception. The emitter.hasRequests() method indicates that a subscriber subscribes to the channel and requested items. So, you can wrap your emission with: 1 2 3 if ( emitter . hasRequests ()) { emitter . send ( \"hello\" ); } If you use the OnOverflow.Strategy.DROP , you can use the send method even with no subscribers nor demands. The message will be nacked immediately. Retrieving channels You can use the @Channel annotation to inject in your bean the underlying stream. Note that in this case, you will be responsible for the subscription: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Inject @Channel ( \"my-channel\" ) Multi < String > streamOfPayloads ; @Inject @Channel ( \"my-channel\" ) Multi < Message < String >> streamOfMessages ; @Inject @Channel ( \"my-channel\" ) Publisher < String > publisherOfPayloads ; @Inject @Channel ( \"my-channel\" ) Publisher < Message < String >> publisherOfMessages ; Important You must have a @Outgoing(\"my-channel\") somewhere in your application (meaning a method generating messages transiting on the channel my-channel ), or an inbound connector configured to manage the prices channel ( mp.messaging.incoming.prices... ) Injected channels merge all the matching outgoing - so if you have multiple @Outgoing(\"out\") , @Inject @Channel(\"out\") gets all the messages. If your injected channel receives payloads ( Multi<T> ), it acknowledges the message automatically, and support multiple subscribers. If you injected channel receives Message ( Multi<Message<T>> ), you will be responsible for the acknowledgement and broadcasting. Emitter and @Broadcast When using an Emitter , you can now @Broadcast what is emitted to all subscribers. Here is an example of emitting a price with two methods marked @Incoming to receive the broadcast: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Inject @Broadcast @Channel ( \"prices\" ) Emitter < Double > emitter ; public void emit ( double d ) { emitter . send ( d ); } @Incoming ( \"prices\" ) public void handle ( double d ) { // Handle the new price } @Incoming ( \"prices\" ) public void audit ( double d ) { // Audit the price change } For more details see @Broadcast documentation. Mutiny Emitter If you prefer to utilize Uni in all your code, there is now a MutinyEmitter that will return Uni<Void> instead of void . 1 2 3 4 5 6 7 @Inject @Channel ( \"prices\" ) MutinyEmitter < Double > emitter ; public Uni < Void > send ( double d ) { return emitter . send ( d ); } There\u2019s also the ability to block on sending the event to the emitter. It will only return from the method when the event is acknowledged, or nacked, by the receiver: 1 2 3 public void sendAwait ( double d ) { emitter . sendAndAwait ( d ); } And if you don\u2019t need to worry about the success or failure of sending an event, you can sendAndForget : 1 2 3 public Cancellable sendForget ( double d ) { return emitter . sendAndForget ( d ); }","title":"Emitters and Channel"},{"location":"concepts/emitter/#emitter-and-channels","text":"It is not rare to combine in a single application imperative parts (Jax-RS, regular CDI beans ) and reactive parts ( beans with @Incoming and @Outgoing annotations). In these case, it\u2019s often required to send messages from the imperative part to the reactive part. In other words, send messages to channels handled by reactive messaging and how can you retrieve messages.","title":"Emitter and Channels"},{"location":"concepts/emitter/#emitter-and-channel","text":"To send things (payload or Message ) from imperative code to a specific channel you need to use: the org.eclipse.microprofile.reactive.messaging.Channel annotations the org.eclipse.microprofile.reactive.messaging.Emitter type The @Channel lets you indicate to which channel you are going to send your payloads or messages. The Emitter is the object to use to send these payloads or messages. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.eclipse.microprofile.reactive.messaging.Channel ; import org.eclipse.microprofile.reactive.messaging.Emitter ; @ApplicationScoped public class MyImperativeBean { @Inject @Channel ( \"prices\" ) Emitter < Double > emitter ; // ... public void send ( double d ) { emitter . send ( d ); } } The Emitter class takes a type parameter. It\u2019s the type of payload. Even if you want to send Messages , the type is the payload type. Important You must have a @Incoming(\"prices\") somewhere in your application (meaning a method consuming messages transiting on the channel prices ), or an outbound connector configured to manage the prices channel ( mp.messaging.outgoing.prices... )","title":"Emitter and @Channel"},{"location":"concepts/emitter/#sending-payloads","text":"Sending payloads is done as follows: 1 2 3 4 5 6 7 @Inject @Channel ( \"prices\" ) Emitter < Double > emitterForPrices ; public void send ( double d ) { emitterForPrices . send ( d ); } When sending a payload, the emitter returns a CompletionStage . This CompletionStage gets completed once the message created from the payload is acknowledged: 1 2 3 4 5 6 public void sendAndAwaitAcknowledgement ( double d ) { CompletionStage < Void > acked = emitterForPrices . send ( d ); // sending a payload returns a CompletionStage completed // when the message is acknowledged acked . toCompletableFuture (). join (); } If the processing fails, the CompletionStage gets completed exceptionally (with the reason of the nack).","title":"Sending payloads"},{"location":"concepts/emitter/#sending-messages","text":"You can also send Messages : 1 2 3 public void sendAsMessage ( double d ) { emitterForPrices . send ( Message . of ( d )); } When sending a Message , the emitter does not return a CompletionStage , but you can pass the ack/nack callback, and be called when the message is acked/nacked. 1 2 3 4 5 6 7 8 9 10 public void sendAsMessageWithAck ( double d ) { emitterForPrices . send ( Message . of ( d , () -> { // Called when the message is acknowledged. return CompletableFuture . completedFuture ( null ); }, reason -> { // Called when the message is acknowledged negatively. return CompletableFuture . completedFuture ( null ); })); } Sending messages also let you pass metadata. 1 2 3 4 5 6 7 8 9 10 11 12 public void sendAsMessageWithAckAndMetadata ( double d ) { MyMetadata metadata = new MyMetadata (); emitterForPrices . send ( Message . of ( d , Metadata . of ( metadata ), () -> { // Called when the message is acknowledged. return CompletableFuture . completedFuture ( null ); }, reason -> { // Called when the message is acknowledged negatively. return CompletableFuture . completedFuture ( null ); })); } Metadata can be used to propagate some context objects with the message.","title":"Sending messages"},{"location":"concepts/emitter/#overflow-management","text":"When sending messages from imperative code to reactive code, you must be aware of back-pressure. Indeed, messages sent using the emitter and stored in a queue . If the consumer does not process the messages quickly enough, this queue can become a memory hog and you may even run out of memory. To control what need to happen when the queue becomes out of control, use the OnOverflow annotation. @OnOverflow lets you configure: the maximum size of the queue (default is 256) what needs to happen when this size is reached (fail, drop...) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Set the max size to 10 and fail if reached @OnOverflow ( value = OnOverflow . Strategy . BUFFER , bufferSize = 10 ) @Inject @Channel ( \"channel\" ) Emitter < String > emitterWithBuffer ; // [DANGER ZONE] no limit @OnOverflow ( OnOverflow . Strategy . UNBOUNDED_BUFFER ) @Inject @Channel ( \"channel\" ) Emitter < String > danger ; // Drop the new messages if the size is reached @OnOverflow ( OnOverflow . Strategy . DROP ) @Inject @Channel ( \"channel\" ) Emitter < String > dropping ; // Drop the previously sent messages if the size is reached @OnOverflow ( OnOverflow . Strategy . LATEST ) @Inject @Channel ( \"channel\" ) Emitter < String > dropOldMessages ; The supported strategies are: OnOverflow.Strategy.BUFFER - use a buffer to store the elements until they are consumed. If the buffer is full, a failure is propagated (and the thread using the emitted gets an exception) OnOverflow.Strategy.UNBOUNDED_BUFFER - use an unbounded buffer to store the elements OnOverflow.Strategy.DROP - drops the most recent value if the downstream can\u2019t keep up. It means that new value emitted by the emitter are ignored. OnOverflow.Strategy.FAIL - propagates a failure in case the downstream can\u2019t keep up. OnOverflow.Strategy.LATEST - keeps only the latest value, dropping any previous value if the downstream can\u2019t keep up. OnOverflow.Strategy.NONE - ignore the back-pressure signals letting the downstream consumer to implement a strategy.","title":"Overflow management"},{"location":"concepts/emitter/#defensive-emission","text":"Having an emitter injected into your code does not guarantee that someone is ready to consume the message. For example, a subscriber may be connecting to a remote broker. If there are no subscribers, using the send method will throw an exception. The emitter.hasRequests() method indicates that a subscriber subscribes to the channel and requested items. So, you can wrap your emission with: 1 2 3 if ( emitter . hasRequests ()) { emitter . send ( \"hello\" ); } If you use the OnOverflow.Strategy.DROP , you can use the send method even with no subscribers nor demands. The message will be nacked immediately.","title":"Defensive emission"},{"location":"concepts/emitter/#retrieving-channels","text":"You can use the @Channel annotation to inject in your bean the underlying stream. Note that in this case, you will be responsible for the subscription: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Inject @Channel ( \"my-channel\" ) Multi < String > streamOfPayloads ; @Inject @Channel ( \"my-channel\" ) Multi < Message < String >> streamOfMessages ; @Inject @Channel ( \"my-channel\" ) Publisher < String > publisherOfPayloads ; @Inject @Channel ( \"my-channel\" ) Publisher < Message < String >> publisherOfMessages ; Important You must have a @Outgoing(\"my-channel\") somewhere in your application (meaning a method generating messages transiting on the channel my-channel ), or an inbound connector configured to manage the prices channel ( mp.messaging.incoming.prices... ) Injected channels merge all the matching outgoing - so if you have multiple @Outgoing(\"out\") , @Inject @Channel(\"out\") gets all the messages. If your injected channel receives payloads ( Multi<T> ), it acknowledges the message automatically, and support multiple subscribers. If you injected channel receives Message ( Multi<Message<T>> ), you will be responsible for the acknowledgement and broadcasting.","title":"Retrieving channels"},{"location":"concepts/emitter/#emitter-and-broadcast","text":"When using an Emitter , you can now @Broadcast what is emitted to all subscribers. Here is an example of emitting a price with two methods marked @Incoming to receive the broadcast: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Inject @Broadcast @Channel ( \"prices\" ) Emitter < Double > emitter ; public void emit ( double d ) { emitter . send ( d ); } @Incoming ( \"prices\" ) public void handle ( double d ) { // Handle the new price } @Incoming ( \"prices\" ) public void audit ( double d ) { // Audit the price change } For more details see @Broadcast documentation.","title":"Emitter and @Broadcast"},{"location":"concepts/emitter/#mutiny-emitter","text":"If you prefer to utilize Uni in all your code, there is now a MutinyEmitter that will return Uni<Void> instead of void . 1 2 3 4 5 6 7 @Inject @Channel ( \"prices\" ) MutinyEmitter < Double > emitter ; public Uni < Void > send ( double d ) { return emitter . send ( d ); } There\u2019s also the ability to block on sending the event to the emitter. It will only return from the method when the event is acknowledged, or nacked, by the receiver: 1 2 3 public void sendAwait ( double d ) { emitter . sendAndAwait ( d ); } And if you don\u2019t need to worry about the success or failure of sending an event, you can sendAndForget : 1 2 3 public Cancellable sendForget ( double d ) { return emitter . sendAndForget ( d ); }","title":"Mutiny Emitter"},{"location":"concepts/incomings/","text":"Multiple Incoming Channels Experimental Multiple @Incomings is an experimental feature. The @Incoming annotation is repeatable. It means that the method receives the messages transiting on every listed channels, in no specific order: 1 2 3 4 5 6 @Incoming ( \"channel-1\" ) @Incoming ( \"channel-2\" ) public String process ( String s ) { // get messages from channel-1 and channel-2 return s . toUpperCase (); }","title":"@Incomings"},{"location":"concepts/incomings/#multiple-incoming-channels","text":"Experimental Multiple @Incomings is an experimental feature. The @Incoming annotation is repeatable. It means that the method receives the messages transiting on every listed channels, in no specific order: 1 2 3 4 5 6 @Incoming ( \"channel-1\" ) @Incoming ( \"channel-2\" ) public String process ( String s ) { // get messages from channel-1 and channel-2 return s . toUpperCase (); }","title":"Multiple Incoming Channels"},{"location":"concepts/logging/","text":"Logging SmallRye Reactive Messaging uses JBoss Logging as logging API. This section explains how to configure the loggers for various logging backends. Tip If you are developing SmallRye Reactive Messaging and wonder about how the logs are managed, it uses JBoss Logging Tools . Logging Backends SmallRye Reactive Messaging uses the JBoss Logging library to write messages to a log file. This library is a logging bridge that integrates different log frameworks. You can decide which of the following frameworks you want to use for your application: JBoss LogManager ( jboss ) Log4j 2 ( log4j2 ) Log4j 1 ( log4j ) Slf4j ( slf4j ) JDK logging ( jul ) You only need to add the chosen framework to the classpath, and the JBoss Logging library will pick it up. If there are multiple frameworks available on the classpath, it picks the first found (in the order from the list). Alternatively, you can set the org.jboss.logging.provider system property is one of the values given above. The concepts and log categories are the same for all frameworks. However, the format of the configuration file and the names of the log levels differ. Check the documentation of your logging library to find out which dependencies are required, the exact name of the log levels, and where the configuration should be written. Log Categories As all applications and frameworks, SmallRye Reactive Messaging writes log messages in different categories and log levels. The categories group messages from specific connectors, classes or components. The following table shows the essential log categories used by SmallRye Reactive Messaging: Category Description io.smallrye.reactive.messaging This category contains all the messages written by SmallRye Reactive Messaging. io.smallrye.reactive.messaging.provider This category contains all the messages generated by the core (provider). io.smallrye.reactive.messaging.kafka This category contains all the messages generated by the Kafka Connector. io.smallrye.reactive.messaging.amqp This category contains all the messages generated by the AMQP Connector. io.smallrye.reactive.messaging.jms This category contains all the messages generated by the JMS Connector. io.smallrye.reactive.messaging.camel This category contains all the messages generated by the Camel Connector. io.smallrye.reactive.messaging.mqtt This category contains all the messages generated by the MQTT (Client) Connector. io.smallrye.reactive.messaging.mqtt-server This category contains all the messages generated by the MQTT (Server) Connector. The names of the log levels are defined by your logging framework and determine the amount and granularity of the log messages. You can assign a log level to each category. If you do not specify a specific category\u2019s log level, it will inherit the level from its parent category. Thus, setting the log level of io.smallrye.reactive.messaging influences every loggers from SmallRye Reactive Messaging. Message Code Each message has an identifier code. They are all prefixed with SRMSG , followed with the numeric code. In the following output, the code is SRMSG00229 : 1 [2020-06-15 13:35:07] [INFO ] SRMSG00229: Channel manager initializing... Recommended logging configurations Development Log4J 1 log4j.properties 1 2 3 4 5 6 7 8 log4j.appender.stdout = org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target = System.out log4j.appender.stdout.layout = org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern = %d{HH:mm:ss,SSS} %-5p [%c] - %m%n log4j.rootLogger = info, stdout log4j.logger.io.smallrye.reactive.messaging = info log4j.logger.org.jboss.weld = warn Log4J 2 log4j2.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 <Configuration monitorInterval= \"60\" > <Properties> <Property name= \"log-path\" > PropertiesConfiguration </Property> </Properties> <Appenders> <Console name= \"Console-Appender\" target= \"SYSTEM*OUT\" > <PatternLayout> <pattern> [%-5level] %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %c{1} - %msg%n </pattern> > </PatternLayout> </Console> </Appenders> <Loggers> <Logger name= \"io.smallrye.reactive.messaging\" level= \"info\" additivity= \"false\" > <AppenderRef ref= \"Console-Appender\" /> </Logger> <Logger name= \"org.jboss.weld\" level= \"warn\" additivity= \"false\" > <AppenderRef ref= \"Console-Appender\" /> </Logger> <Root level= \"info\" > <AppenderRef ref= \"Console-Appender\" /> </Root> </Loggers> </Configuration> JDK (JUL) logging.properties 1 2 3 4 5 6 7 8 9 handlers = java.util.logging.ConsoleHandler java.util.logging.ConsoleHandler.level = FINEST java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter java.util.logging.SimpleFormatter.format = [%1$tF %1$tT] [%4$-7s] %5$s %n .level = INFO io.smallrye.reactive.messaging.level = INFO org.jboss.weld.level = WARNING LogBack via SLF4J* logback.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <configuration> <appender name= \"STDOUT\" class= \"ch.qos.logback.core.ConsoleAppender\" > <encoder class= \"ch.qos.logback.classic.encoder.PatternLayoutEncoder\" > <Pattern> %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n </Pattern> </encoder> </appender> <logger name= \"io.smallrye.reactive.messaging\" level= \"info\" additivity= \"false\" > <appender-ref ref= \"STDOUT\" /> </logger> <logger name= \"org.jboss.weld\" level= \"warn\" additivity= \"false\" > <appender-ref ref= \"STDOUT\" /> </logger> <root level= \"info\" > <appender-ref ref= \"STDOUT\" /> </root> </configuration> Production Log4J 1 log4j.properties 1 2 3 4 5 6 7 8 log4j.appender.stdout = org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target = System.out log4j.appender.stdout.layout = org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern = %d{HH:mm:ss,SSS} %-5p [%c] - %m%n log4j.rootLogger = info, stdout log4j.logger.io.smallrye.reactive.messaging = warn log4j.logger.org.jboss.weld = error Log4J 2 log4j2.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 <Configuration monitorInterval= \"60\" > <Properties> <Property name= \"log-path\" > PropertiesConfiguration </Property> </Properties> <Appenders> <Console name= \"Console-Appender\" target= \"SYSTEM*OUT\" > <PatternLayout> <pattern> [%-5level] %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %c{1} - %msg%n </pattern> > </PatternLayout> </Console> </Appenders> <Loggers> <Logger name= \"io.smallrye.reactive.messaging\" level= \"warn\" additivity= \"false\" > <AppenderRef ref= \"Console-Appender\" /> </Logger> <Logger name= \"org.jboss.weld\" level= \"error\" additivity= \"false\" > <AppenderRef ref= \"Console-Appender\" /> </Logger> <Root level= \"info\" > <AppenderRef ref= \"Console-Appender\" /> </Root> </Loggers> </Configuration> JDK (JUL) logging.properties 1 2 3 4 5 6 7 8 9 handlers = java.util.logging.ConsoleHandler java.util.logging.ConsoleHandler.level = INFO java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter java.util.logging.SimpleFormatter.format = [%1$tF %1$tT] [%4$-7s] %5$s %n .level = INFO io.smallrye.reactive.messaging.level = WARNING org.jboss.weld.level = SEVERE logback.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <configuration> <appender name= \"STDOUT\" class= \"ch.qos.logback.core.ConsoleAppender\" > <encoder class= \"ch.qos.logback.classic.encoder.PatternLayoutEncoder\" > <Pattern> %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n </Pattern> </encoder> </appender> <logger name= \"io.smallrye.reactive.messaging\" level= \"warn\" additivity= \"false\" > <appender-ref ref= \"STDOUT\" /> </logger> <logger name= \"org.jboss.weld\" level= \"error\" additivity= \"false\" > <appender-ref ref= \"STDOUT\" /> </logger> <root level= \"info\" > <appender-ref ref= \"STDOUT\" /> </root> </configuration>","title":"Logging"},{"location":"concepts/logging/#logging","text":"SmallRye Reactive Messaging uses JBoss Logging as logging API. This section explains how to configure the loggers for various logging backends. Tip If you are developing SmallRye Reactive Messaging and wonder about how the logs are managed, it uses JBoss Logging Tools .","title":"Logging"},{"location":"concepts/logging/#logging-backends","text":"SmallRye Reactive Messaging uses the JBoss Logging library to write messages to a log file. This library is a logging bridge that integrates different log frameworks. You can decide which of the following frameworks you want to use for your application: JBoss LogManager ( jboss ) Log4j 2 ( log4j2 ) Log4j 1 ( log4j ) Slf4j ( slf4j ) JDK logging ( jul ) You only need to add the chosen framework to the classpath, and the JBoss Logging library will pick it up. If there are multiple frameworks available on the classpath, it picks the first found (in the order from the list). Alternatively, you can set the org.jboss.logging.provider system property is one of the values given above. The concepts and log categories are the same for all frameworks. However, the format of the configuration file and the names of the log levels differ. Check the documentation of your logging library to find out which dependencies are required, the exact name of the log levels, and where the configuration should be written.","title":"Logging Backends"},{"location":"concepts/logging/#log-categories","text":"As all applications and frameworks, SmallRye Reactive Messaging writes log messages in different categories and log levels. The categories group messages from specific connectors, classes or components. The following table shows the essential log categories used by SmallRye Reactive Messaging: Category Description io.smallrye.reactive.messaging This category contains all the messages written by SmallRye Reactive Messaging. io.smallrye.reactive.messaging.provider This category contains all the messages generated by the core (provider). io.smallrye.reactive.messaging.kafka This category contains all the messages generated by the Kafka Connector. io.smallrye.reactive.messaging.amqp This category contains all the messages generated by the AMQP Connector. io.smallrye.reactive.messaging.jms This category contains all the messages generated by the JMS Connector. io.smallrye.reactive.messaging.camel This category contains all the messages generated by the Camel Connector. io.smallrye.reactive.messaging.mqtt This category contains all the messages generated by the MQTT (Client) Connector. io.smallrye.reactive.messaging.mqtt-server This category contains all the messages generated by the MQTT (Server) Connector. The names of the log levels are defined by your logging framework and determine the amount and granularity of the log messages. You can assign a log level to each category. If you do not specify a specific category\u2019s log level, it will inherit the level from its parent category. Thus, setting the log level of io.smallrye.reactive.messaging influences every loggers from SmallRye Reactive Messaging.","title":"Log Categories"},{"location":"concepts/logging/#message-code","text":"Each message has an identifier code. They are all prefixed with SRMSG , followed with the numeric code. In the following output, the code is SRMSG00229 : 1 [2020-06-15 13:35:07] [INFO ] SRMSG00229: Channel manager initializing...","title":"Message Code"},{"location":"concepts/logging/#recommended-logging-configurations","text":"","title":"Recommended logging configurations"},{"location":"concepts/logging/#development","text":"","title":"Development"},{"location":"concepts/logging/#production","text":"","title":"Production"},{"location":"concepts/merge/","text":"Merge channels Experimental @Merge is an experimental feature. By default, messages transiting in a channel can arise from a single producer. Having multiple producers is considered erroneous and is reported at deployment time. The Merge annotation changes this behavior and indicates that a channel can have multiple producers. @Merge must be used with the @Incoming annotation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Incoming ( \"in1\" ) @Outgoing ( \"out\" ) public int increment ( int i ) { return i + 1 ; } @Incoming ( \"in2\" ) @Outgoing ( \"out\" ) public int multiply ( int i ) { return i * 2 ; } @Incoming ( \"out\" ) @Merge public void getAll ( int i ) { //... } In the previous example, the consumer gets all the messages (from both producers). The @Merge annotation allows configuring how the incoming messages (from the different producers) are merged into the channel. The mode attribute allows configuring this behavior: ONE picks a single producer, discarding the other producer; MERGE (default) gets all the messages as they come, without any defined order. Messages from different producers may be interleaved. CONCAT concatenates the producers. The messages from one producer are received until the messages from other producers are received. Note Outbound connectors also support a merge attribute that allows consuming the messages to multiple upstreams. It will dispatch all the received messages.","title":"Merge channels"},{"location":"concepts/merge/#merge-channels","text":"Experimental @Merge is an experimental feature. By default, messages transiting in a channel can arise from a single producer. Having multiple producers is considered erroneous and is reported at deployment time. The Merge annotation changes this behavior and indicates that a channel can have multiple producers. @Merge must be used with the @Incoming annotation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Incoming ( \"in1\" ) @Outgoing ( \"out\" ) public int increment ( int i ) { return i + 1 ; } @Incoming ( \"in2\" ) @Outgoing ( \"out\" ) public int multiply ( int i ) { return i * 2 ; } @Incoming ( \"out\" ) @Merge public void getAll ( int i ) { //... } In the previous example, the consumer gets all the messages (from both producers). The @Merge annotation allows configuring how the incoming messages (from the different producers) are merged into the channel. The mode attribute allows configuring this behavior: ONE picks a single producer, discarding the other producer; MERGE (default) gets all the messages as they come, without any defined order. Messages from different producers may be interleaved. CONCAT concatenates the producers. The messages from one producer are received until the messages from other producers are received. Note Outbound connectors also support a merge attribute that allows consuming the messages to multiple upstreams. It will dispatch all the received messages.","title":"Merge channels"},{"location":"concepts/model/","text":"Development Model Reactive Messaging proposes a CDI-based programming model to implement event-driven applications. Following the CDI principles, beans are forming the main building block of your application. Reactive Messaging provides a set of annotations and types to implement beans that generate, consume or process messages. @Incoming and @Outgoing Reactive Messaging provides two main annotations: org.eclipse.microprofile.reactive.messaging.Incoming - indicates the consumed channel org.eclipse.microprofile.reactive.messaging.Outgoing - indicates the populated channel These annotations are used on methods : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package beans ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; @ApplicationScoped public class MessageProcessingBean { @Incoming ( \"consumed-channel\" ) @Outgoing ( \"populated-channel\" ) public Message < String > process ( Message < String > in ) { // Process the payload String payload = in . getPayload (). toUpperCase (); // Create a new message from `in` and just update the payload return in . withPayload ( payload ); } } Note Reactive Messaging beans can either be in the application scope ( @ApplicationScoped ) or dependent scope ( @Dependent ). Manipulating messages can be cumbersome. When you are only interested in the payload, you can use the following syntax: The following code is equivalent to the snippet from above: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package beans ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; @ApplicationScoped public class PayloadProcessingBean { @Incoming ( \"consumed-channel\" ) @Outgoing ( \"populated-channel\" ) public String process ( String in ) { return in . toUpperCase (); } } Important You should not call methods annotated with @Incoming and/or @Outgoing directly from your code. They are invoked by the framework. Having user code invoking them would not have the expected outcome. SmallRye Reactive Messaging automatically binds matching @Outgoing to @Incoming to form a chain: A chain of components If we consider the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Outgoing ( \"source\" ) public Multi < String > generate () { return Multi . createFrom (). items ( \"Hello\" , \"from\" , \"reactive\" , \"messaging\" ); } @Incoming ( \"source\" ) @Outgoing ( \"sink\" ) public String process ( String in ) { return in . toUpperCase (); } @Incoming ( \"sink\" ) public void consume ( String processed ) { System . out . println ( processed ); } It would generate the following chain: 1 generate --> [ source ] --> process --> [ sink ] --> consume Methods annotated with @Incoming or @Outgoing don\u2019t have to be in the same bean ( class ). You can distribute them among a set of beans. Remote interactions are also possible when using connectors. Methods annotated with: only @Outgoing are used to generate messages or payloads only @Incoming are used to consume messages or payloads both @Incoming and @Outgoing are used to process messages or payloads; or transform the stream Creating messages Messages are envelopes around payload. They are the vehicle. While manipulating payload is convenient, messages let you add metadata, handle acknowledgement... Creating Messages is done using the Message interface directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Create a simple message wrapping a payload Message < Price > m1 = Message . of ( price ); // Create a message with metadata Message < Price > m2 = Message . of ( price , Metadata . of ( new PriceMetadata ())); // Create a message with several metadata Message < Price > m3 = Message . of ( price , Metadata . of ( new PriceMetadata (), new MyMetadata ())); // Create a message with an acknowledgement callback Message < Price > m4 = Message . of ( price , () -> { // Called when the message is acknowledged by the next consumer. return CompletableFuture . completedFuture ( null ); }); // Create a message with both metadata and acknowledgement callback Message < Price > m5 = Message . of ( price , Metadata . of ( new PriceMetadata ()), () -> { // Called when the message is acknowledged by the next consumer. return CompletableFuture . completedFuture ( null ); }); You can also create new instance of Message from an existing one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Create a new message with a new payload but with the same metadata Message < Price > m1 = message . withPayload ( new Price ( 12.4 )); // Create a new message with a new payload and add another metadata Message < Price > m2 = message . withPayload ( new Price ( 15.0 )) . withMetadata ( Metadata . of ( new PriceMetadata ())); // Create a new message with a new payload and a custom acknowledgement Message < Price > m3 = message . withPayload ( new Price ( 15.0 )) . withAck (() -> // acknowledge the incoming message message . ack () . thenAccept ( x -> { // do something })); Acknowledgement? Acknowledgement is an important part of messaging systems. This will be covered in the acknowledgement section. Connector Metadata Most connectors are providing metadata to let you extract technical details about the message, but also customize the outbound dispatching. Generating Messages To produce messages to a channel, you need to use the @Outgoing annotation. This annotation takes a single parameter: the name of the populated channel. Generating messages synchronously You can generate messages synchronously. In this case, the method is called for every request from the downstream: 1 2 3 4 @Outgoing ( \"my-channel\" ) public Message < Integer > generateMessagesSynchronously () { return Message . of ( counter . getAndIncrement ()); } Requests? Reactive Messaging connects components to build a reactive stream. In a reactive stream, the emissions are controlled by the consumer (downstream) indicating to the publisher (upstream) how many items it can consume. With this protocol, the consumers are never flooded. Generating messages using CompletionStage You can also return a CompletionStage / CompletableFuture . In this case, Reactive Messaging waits until the CompletionStage gets completed before calling it again. For instance, this signature is useful to poll messages from a source using an asynchronous client: 1 2 3 4 5 @Outgoing ( \"my-channel\" ) public CompletionStage < Message < Price >> generateMessagesAsCompletionStage () { return asyncClient . poll () . thenApply ( Message :: of ); } Generating messages using Uni You can also return a Uni instance. In this case, Reactive Messaging waits until the Uni emits its item before calling it again. This signature is useful when integrating asynchronous clients providing a Mutiny API. 1 2 3 4 @Outgoing ( \"my-channel\" ) public Uni < Message < Integer >> generateMessagesAsync () { return Uni . createFrom (). item (() -> Message . of ( counter . getAndIncrement ())); } Generating Reactive Streams of messages Instead of producing the message one by one, you can return the stream directly. If you have a data source producing Reactive Streams Publisher (or sub-types, such as Multi ), this is the signature you are looking for: 1 2 3 4 public Publisher < Message < String >> generateMessageStream () { Multi < String > multi = reactiveClient . getStream (); return multi . map ( Message :: of ); } In this case, the method is called once to retrieve the Publisher . Generating Payloads Instead of Message , you can produce payloads . In this case, Reactive Messaging produces a simple message from the payload using Message.of . Generating payload synchronously You can produce payloads synchronously. The framework calls the method upon request and create Messages around the produced payloads. 1 2 3 4 @Outgoing ( \"my-channel\" ) public Integer generatePayloadsSynchronously () { return counter . getAndIncrement (); } Generating payload using CompletionStage You can also return CompletionStage or CompletableFuture . For example, if you have an asynchronous client returning CompletionStage , you can use it as follows, to poll the data one by one: 1 2 3 4 @Outgoing ( \"my-channel\" ) public CompletionStage < Price > generatePayloadsAsCompletionStage () { return asyncClient . poll (); } Generating payload by producing Unis You can also return a Uni if you have a client using Mutiny types: 1 2 3 4 @Outgoing ( \"my-channel\" ) public Uni < Integer > generatePayloadsAsync () { return Uni . createFrom (). item (() -> counter . getAndIncrement ()); } Generating Reactive Streams of payloads Finally, you can return a Publisher (or a sub-type such as a Multi ): 1 2 3 4 5 @Outgoing ( \"my-channel\" ) public Multi < String > generatePayloadsStream () { Multi < String > multi = reactiveClient . getStream (); return multi ; } In this case, Reactive Messaging calls the method only once to retrieve the Publisher . Consuming Messages To consume messages from a channel, you need to use the @Incoming annotation. This annotation takes a single parameter: the name of the consumed channel. Because Messages must be acknowledged, consuming messages requires returning asynchronous results that would complete when the incoming message get acknowledged. For example, you can receive the Message , process it and return the acknowledgement as result: 1 2 3 4 5 6 @Incoming ( \"my-channel\" ) public CompletionStage < Void > consumeMessage ( Message < Price > message ) { handle ( message . getPayload ()); return message . ack (); } ' You can also return a Uni if you need to implement more complicated processing: 1 2 3 4 5 6 @Incoming ( \"my-channel\" ) public Uni < Void > consumeMessageUni ( Message < Price > message ) { return Uni . createFrom (). item ( message ) . onItem (). invoke ( m -> handle ( m . getPayload ())) . onItem (). transformToUni ( x -> Uni . createFrom (). completionStage ( message . ack ())); } Consuming Payloads Unlike consuming messages, consuming payloads support both synchronous and asynchronous consumption. For example, you can consume a payload as follows: 1 2 3 4 @Incoming ( \"my-channel\" ) public void consumePayload ( Price payload ) { // do something } In this case, you don\u2019t need to deal with the acknowledgement yourself. The framework acknowledges the incoming message (that wrapped the payload) once your method returns successfully. If you need to achieve asynchronous actions, you can return a CompletionStage or a Uni : 1 2 3 4 5 @Incoming ( \"my-channel\" ) public CompletionStage < Void > consumePayloadCS ( Price payload ) { CompletionStage < Void > cs = handleAsync ( payload ); return cs ; } 1 2 3 4 5 6 @Incoming ( \"my-channel\" ) public Uni < Void > consumePayloadUni ( Price payload ) { return Uni . createFrom (). item ( payload ) . onItem (). invoke ( this :: handle ) . onItem (). ignore (). andContinueWithNull (); } In these 2 cases, the framework acknowledges the incoming message when the returned construct gets completed . Processing Messages You can process Message both synchronously or asynchronously. This later case is useful when you need to execute an asynchronous action during your processing such as invoking a remote service. Do process Messages synchronously uses: 1 2 3 4 5 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Message < String > processMessage ( Message < Integer > in ) { return in . withPayload ( Integer . toString ( in . getPayload ())); } This method transforms the int payload to a String , and wraps it into a Message . '''important \"Using Message.withX methods\" You may be surprised by the usage of Message.withX methods. It allows metadata propagation as the metadata would be copied from the incoming message and so dispatched to the next method. You can also process Messages asynchronously: 1 2 3 4 5 6 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public CompletionStage < Message < String >> processMessageCS ( Message < Integer > in ) { CompletionStage < String > cs = invokeService ( in . getPayload ()); return cs . thenApply ( in :: withPayload ); } Or using Mutiny: 1 2 3 4 5 6 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Uni < Message < String >> processMessageUni ( Message < String > in ) { return invokeService ( in . getPayload ()) . map ( in :: withPayload ); } In general, you want to create the new Message from the incoming one. It enables metadata propagation and post-acknowledgement. For this, use the withX method from the Message class returning a new Message instance but copy the content (metadata, ack/nack...). Processing payloads If you don\u2019t need to manipulate the envelope, you can process payload directly either synchronously or asynchronously: 1 2 3 4 5 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public String processPayload ( int in ) { return Integer . toString ( in ); } 1 2 3 4 5 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public CompletionStage < String > processPayloadCS ( int in ) { return invokeService ( in ); } 1 2 3 4 5 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Uni < String > processPayload ( String in ) { return invokeService ( in ); } What about metadata? With these methods, the metadata are automatically propagated. Processing streams The previous processing method were taking single Message or payload. Sometimes you need more advanced manipulation. For this, SmallRye Reactive Messaging lets you process the stream of Message or the stream of payloads directly: 1 2 3 4 5 6 7 8 9 10 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Multi < Message < String >> processMessageStream ( Multi < Message < Integer >> stream ) { return stream . onItem (). transformToUni ( message -> invokeService ( message . getPayload ()) . onFailure (). recoverWithItem ( \"fallback\" ) . onItem (). transform ( message :: withPayload )) . concatenate (); } 1 2 3 4 5 6 7 8 9 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Multi < String > processPayloadStream ( Multi < Integer > stream ) { return stream . onItem (). transformToUni ( payload -> invokeService ( payload ) . onFailure (). recoverWithItem ( \"fallback\" )) . concatenate (); } You can receive either a (Reactive Streams) Publisher , a PublisherBuilder or (Mutiny) Multi . You can return any subclass of Publisher or a Publisher directly. Important These signatures do not support metadata propagation. In the case of a stream of Message , you need to propagate the metadata manually. In the case of a stream of payload, propagation is not supported, and incoming metadata are lost.","title":"Development Model"},{"location":"concepts/model/#development-model","text":"Reactive Messaging proposes a CDI-based programming model to implement event-driven applications. Following the CDI principles, beans are forming the main building block of your application. Reactive Messaging provides a set of annotations and types to implement beans that generate, consume or process messages.","title":"Development Model"},{"location":"concepts/model/#incoming-and-outgoing","text":"Reactive Messaging provides two main annotations: org.eclipse.microprofile.reactive.messaging.Incoming - indicates the consumed channel org.eclipse.microprofile.reactive.messaging.Outgoing - indicates the populated channel These annotations are used on methods : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package beans ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; @ApplicationScoped public class MessageProcessingBean { @Incoming ( \"consumed-channel\" ) @Outgoing ( \"populated-channel\" ) public Message < String > process ( Message < String > in ) { // Process the payload String payload = in . getPayload (). toUpperCase (); // Create a new message from `in` and just update the payload return in . withPayload ( payload ); } } Note Reactive Messaging beans can either be in the application scope ( @ApplicationScoped ) or dependent scope ( @Dependent ). Manipulating messages can be cumbersome. When you are only interested in the payload, you can use the following syntax: The following code is equivalent to the snippet from above: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package beans ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; @ApplicationScoped public class PayloadProcessingBean { @Incoming ( \"consumed-channel\" ) @Outgoing ( \"populated-channel\" ) public String process ( String in ) { return in . toUpperCase (); } } Important You should not call methods annotated with @Incoming and/or @Outgoing directly from your code. They are invoked by the framework. Having user code invoking them would not have the expected outcome. SmallRye Reactive Messaging automatically binds matching @Outgoing to @Incoming to form a chain: A chain of components If we consider the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Outgoing ( \"source\" ) public Multi < String > generate () { return Multi . createFrom (). items ( \"Hello\" , \"from\" , \"reactive\" , \"messaging\" ); } @Incoming ( \"source\" ) @Outgoing ( \"sink\" ) public String process ( String in ) { return in . toUpperCase (); } @Incoming ( \"sink\" ) public void consume ( String processed ) { System . out . println ( processed ); } It would generate the following chain: 1 generate --> [ source ] --> process --> [ sink ] --> consume Methods annotated with @Incoming or @Outgoing don\u2019t have to be in the same bean ( class ). You can distribute them among a set of beans. Remote interactions are also possible when using connectors. Methods annotated with: only @Outgoing are used to generate messages or payloads only @Incoming are used to consume messages or payloads both @Incoming and @Outgoing are used to process messages or payloads; or transform the stream","title":"@Incoming and @Outgoing"},{"location":"concepts/model/#creating-messages","text":"Messages are envelopes around payload. They are the vehicle. While manipulating payload is convenient, messages let you add metadata, handle acknowledgement... Creating Messages is done using the Message interface directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Create a simple message wrapping a payload Message < Price > m1 = Message . of ( price ); // Create a message with metadata Message < Price > m2 = Message . of ( price , Metadata . of ( new PriceMetadata ())); // Create a message with several metadata Message < Price > m3 = Message . of ( price , Metadata . of ( new PriceMetadata (), new MyMetadata ())); // Create a message with an acknowledgement callback Message < Price > m4 = Message . of ( price , () -> { // Called when the message is acknowledged by the next consumer. return CompletableFuture . completedFuture ( null ); }); // Create a message with both metadata and acknowledgement callback Message < Price > m5 = Message . of ( price , Metadata . of ( new PriceMetadata ()), () -> { // Called when the message is acknowledged by the next consumer. return CompletableFuture . completedFuture ( null ); }); You can also create new instance of Message from an existing one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Create a new message with a new payload but with the same metadata Message < Price > m1 = message . withPayload ( new Price ( 12.4 )); // Create a new message with a new payload and add another metadata Message < Price > m2 = message . withPayload ( new Price ( 15.0 )) . withMetadata ( Metadata . of ( new PriceMetadata ())); // Create a new message with a new payload and a custom acknowledgement Message < Price > m3 = message . withPayload ( new Price ( 15.0 )) . withAck (() -> // acknowledge the incoming message message . ack () . thenAccept ( x -> { // do something })); Acknowledgement? Acknowledgement is an important part of messaging systems. This will be covered in the acknowledgement section. Connector Metadata Most connectors are providing metadata to let you extract technical details about the message, but also customize the outbound dispatching.","title":"Creating messages"},{"location":"concepts/model/#generating-messages","text":"To produce messages to a channel, you need to use the @Outgoing annotation. This annotation takes a single parameter: the name of the populated channel.","title":"Generating Messages"},{"location":"concepts/model/#generating-messages-synchronously","text":"You can generate messages synchronously. In this case, the method is called for every request from the downstream: 1 2 3 4 @Outgoing ( \"my-channel\" ) public Message < Integer > generateMessagesSynchronously () { return Message . of ( counter . getAndIncrement ()); } Requests? Reactive Messaging connects components to build a reactive stream. In a reactive stream, the emissions are controlled by the consumer (downstream) indicating to the publisher (upstream) how many items it can consume. With this protocol, the consumers are never flooded.","title":"Generating messages synchronously"},{"location":"concepts/model/#generating-messages-using-completionstage","text":"You can also return a CompletionStage / CompletableFuture . In this case, Reactive Messaging waits until the CompletionStage gets completed before calling it again. For instance, this signature is useful to poll messages from a source using an asynchronous client: 1 2 3 4 5 @Outgoing ( \"my-channel\" ) public CompletionStage < Message < Price >> generateMessagesAsCompletionStage () { return asyncClient . poll () . thenApply ( Message :: of ); }","title":"Generating messages using CompletionStage"},{"location":"concepts/model/#generating-messages-using-uni","text":"You can also return a Uni instance. In this case, Reactive Messaging waits until the Uni emits its item before calling it again. This signature is useful when integrating asynchronous clients providing a Mutiny API. 1 2 3 4 @Outgoing ( \"my-channel\" ) public Uni < Message < Integer >> generateMessagesAsync () { return Uni . createFrom (). item (() -> Message . of ( counter . getAndIncrement ())); }","title":"Generating messages using Uni"},{"location":"concepts/model/#generating-reactive-streams-of-messages","text":"Instead of producing the message one by one, you can return the stream directly. If you have a data source producing Reactive Streams Publisher (or sub-types, such as Multi ), this is the signature you are looking for: 1 2 3 4 public Publisher < Message < String >> generateMessageStream () { Multi < String > multi = reactiveClient . getStream (); return multi . map ( Message :: of ); } In this case, the method is called once to retrieve the Publisher .","title":"Generating Reactive Streams of messages"},{"location":"concepts/model/#generating-payloads","text":"Instead of Message , you can produce payloads . In this case, Reactive Messaging produces a simple message from the payload using Message.of .","title":"Generating Payloads"},{"location":"concepts/model/#generating-payload-synchronously","text":"You can produce payloads synchronously. The framework calls the method upon request and create Messages around the produced payloads. 1 2 3 4 @Outgoing ( \"my-channel\" ) public Integer generatePayloadsSynchronously () { return counter . getAndIncrement (); }","title":"Generating payload synchronously"},{"location":"concepts/model/#generating-payload-using-completionstage","text":"You can also return CompletionStage or CompletableFuture . For example, if you have an asynchronous client returning CompletionStage , you can use it as follows, to poll the data one by one: 1 2 3 4 @Outgoing ( \"my-channel\" ) public CompletionStage < Price > generatePayloadsAsCompletionStage () { return asyncClient . poll (); }","title":"Generating payload using CompletionStage"},{"location":"concepts/model/#generating-payload-by-producing-unis","text":"You can also return a Uni if you have a client using Mutiny types: 1 2 3 4 @Outgoing ( \"my-channel\" ) public Uni < Integer > generatePayloadsAsync () { return Uni . createFrom (). item (() -> counter . getAndIncrement ()); }","title":"Generating payload by producing Unis"},{"location":"concepts/model/#generating-reactive-streams-of-payloads","text":"Finally, you can return a Publisher (or a sub-type such as a Multi ): 1 2 3 4 5 @Outgoing ( \"my-channel\" ) public Multi < String > generatePayloadsStream () { Multi < String > multi = reactiveClient . getStream (); return multi ; } In this case, Reactive Messaging calls the method only once to retrieve the Publisher .","title":"Generating Reactive Streams of payloads"},{"location":"concepts/model/#consuming-messages","text":"To consume messages from a channel, you need to use the @Incoming annotation. This annotation takes a single parameter: the name of the consumed channel. Because Messages must be acknowledged, consuming messages requires returning asynchronous results that would complete when the incoming message get acknowledged. For example, you can receive the Message , process it and return the acknowledgement as result: 1 2 3 4 5 6 @Incoming ( \"my-channel\" ) public CompletionStage < Void > consumeMessage ( Message < Price > message ) { handle ( message . getPayload ()); return message . ack (); } ' You can also return a Uni if you need to implement more complicated processing: 1 2 3 4 5 6 @Incoming ( \"my-channel\" ) public Uni < Void > consumeMessageUni ( Message < Price > message ) { return Uni . createFrom (). item ( message ) . onItem (). invoke ( m -> handle ( m . getPayload ())) . onItem (). transformToUni ( x -> Uni . createFrom (). completionStage ( message . ack ())); }","title":"Consuming Messages"},{"location":"concepts/model/#consuming-payloads","text":"Unlike consuming messages, consuming payloads support both synchronous and asynchronous consumption. For example, you can consume a payload as follows: 1 2 3 4 @Incoming ( \"my-channel\" ) public void consumePayload ( Price payload ) { // do something } In this case, you don\u2019t need to deal with the acknowledgement yourself. The framework acknowledges the incoming message (that wrapped the payload) once your method returns successfully. If you need to achieve asynchronous actions, you can return a CompletionStage or a Uni : 1 2 3 4 5 @Incoming ( \"my-channel\" ) public CompletionStage < Void > consumePayloadCS ( Price payload ) { CompletionStage < Void > cs = handleAsync ( payload ); return cs ; } 1 2 3 4 5 6 @Incoming ( \"my-channel\" ) public Uni < Void > consumePayloadUni ( Price payload ) { return Uni . createFrom (). item ( payload ) . onItem (). invoke ( this :: handle ) . onItem (). ignore (). andContinueWithNull (); } In these 2 cases, the framework acknowledges the incoming message when the returned construct gets completed .","title":"Consuming Payloads"},{"location":"concepts/model/#processing-messages","text":"You can process Message both synchronously or asynchronously. This later case is useful when you need to execute an asynchronous action during your processing such as invoking a remote service. Do process Messages synchronously uses: 1 2 3 4 5 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Message < String > processMessage ( Message < Integer > in ) { return in . withPayload ( Integer . toString ( in . getPayload ())); } This method transforms the int payload to a String , and wraps it into a Message . '''important \"Using Message.withX methods\" You may be surprised by the usage of Message.withX methods. It allows metadata propagation as the metadata would be copied from the incoming message and so dispatched to the next method. You can also process Messages asynchronously: 1 2 3 4 5 6 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public CompletionStage < Message < String >> processMessageCS ( Message < Integer > in ) { CompletionStage < String > cs = invokeService ( in . getPayload ()); return cs . thenApply ( in :: withPayload ); } Or using Mutiny: 1 2 3 4 5 6 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Uni < Message < String >> processMessageUni ( Message < String > in ) { return invokeService ( in . getPayload ()) . map ( in :: withPayload ); } In general, you want to create the new Message from the incoming one. It enables metadata propagation and post-acknowledgement. For this, use the withX method from the Message class returning a new Message instance but copy the content (metadata, ack/nack...).","title":"Processing Messages"},{"location":"concepts/model/#processing-payloads","text":"If you don\u2019t need to manipulate the envelope, you can process payload directly either synchronously or asynchronously: 1 2 3 4 5 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public String processPayload ( int in ) { return Integer . toString ( in ); } 1 2 3 4 5 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public CompletionStage < String > processPayloadCS ( int in ) { return invokeService ( in ); } 1 2 3 4 5 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Uni < String > processPayload ( String in ) { return invokeService ( in ); } What about metadata? With these methods, the metadata are automatically propagated.","title":"Processing payloads"},{"location":"concepts/model/#processing-streams","text":"The previous processing method were taking single Message or payload. Sometimes you need more advanced manipulation. For this, SmallRye Reactive Messaging lets you process the stream of Message or the stream of payloads directly: 1 2 3 4 5 6 7 8 9 10 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Multi < Message < String >> processMessageStream ( Multi < Message < Integer >> stream ) { return stream . onItem (). transformToUni ( message -> invokeService ( message . getPayload ()) . onFailure (). recoverWithItem ( \"fallback\" ) . onItem (). transform ( message :: withPayload )) . concatenate (); } 1 2 3 4 5 6 7 8 9 @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Multi < String > processPayloadStream ( Multi < Integer > stream ) { return stream . onItem (). transformToUni ( payload -> invokeService ( payload ) . onFailure (). recoverWithItem ( \"fallback\" )) . concatenate (); } You can receive either a (Reactive Streams) Publisher , a PublisherBuilder or (Mutiny) Multi . You can return any subclass of Publisher or a Publisher directly. Important These signatures do not support metadata propagation. In the case of a stream of Message , you need to propagate the metadata manually. In the case of a stream of payload, propagation is not supported, and incoming metadata are lost.","title":"Processing streams"},{"location":"concepts/signatures/","text":"Supported signatures The following tables list the supported method signatures and indicate the various supported features. For instance, they indicate the default and available acknowledgement strategies (when applicable). Signature Invocation time @Outgoing Publisher<Message<O>> method() ` Called once at assembly time @Outgoing Publisher<O> method() ` Called once at assembly time @Outgoing Multi<Message<O>> method() ` Called once at assembly time @Outgoing Multi<O> method() ` Called once at assembly time @Outgoing PublisherBuilder<Message<O>> method() ` Called once at assembly time @Outgoing PublisherBuilder<O> method() ` Called once at assembly time @Outgoing Message<O> method() ` Called for every downstream request, sequentially @Outgoing O method() ` Called for every downstream request, sequentially @Outgoing CompletionStage<Message<O>> method() ` Called for every downstream request, sequentially (After the completion of the last returned CompletionStage) @Outgoing CompletionStage<O> method() ` Called for every downstream request, , sequentially (After the completion of the last returned CompletionStage) @Outgoing Uni<Message<O>> method() ` Called for every downstream request, sequentially (After the completion of the last returned Uni) @Outgoing Uni<O> method() ` Called for every downstream request, , sequentially (After the completion of the last returned Uni) Method signatures to generate data Signature Invocation time Supported Acknowledgement Strategies @Incoming void method(I p) Called for every incoming payload (sequentially) POST_PROCESSING , NONE, PRE_PROCESSING @Incoming CompletionStage<?> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING @Incoming CompletionStage<?> method(I p) Called for every incoming payload (sequentially) POST_PROCESSING , PRE_PROCESSING, NONE @Incoming Uni<?> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING @Incoming Uni<?> method(I p) Called for every incoming payload (sequentially) POST_PROCESSING , PRE_PROCESSING, NONE @Incoming Subscriber<Message<I>> method() Called once at assembly time MANUAL , POST_PROCESSING, NONE, PRE_PROCESSING @Incoming Subscriber<I> method() Called once at assembly time POST_PROCESSING , NONE, PRE_PROCESSING Method signatures to consume data Signature Invocation time Supported Acknowledgement Strategies Metadata Propagation @Outgoing @Incoming Message<O> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming O method(I payload) Called for every incoming payload (sequentially) POST_PROCESSING , NONE, PRE_PROCESSING automatic @Outgoing @Incoming CompletionStage<Message<O>> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming CompletionStage<O> method(I payload) Called for every incoming payload (sequentially) POST_PROCESSING , NONE, PRE_PROCESSING automatic @Outgoing @Incoming Uni<Message<O>> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming Uni<O> method(I payload) Called for every incoming payload (sequentially) POST_PROCESSING , NONE, PRE_PROCESSING automatic @Outgoing @Incoming Processor<Message<I>, Message<O>> method() Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming Processor<I, O> method() Called once at assembly time PRE_PROCESSING , NONE not supported @Outgoing @Incoming ProcessorBuilder<Message<I>, Message<O>> method() Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming ProcessorBuilder<I, O> method() Called once at assembly time PRE_PROCESSING , NONE not supported @Outgoing @Incoming Publisher<Message<O>> method(Message<I> msg) Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming Publisher<O> method(I payload) Called once at assembly time PRE_PROCESSING , NONE automatic @Outgoing @Incoming Multi<Message<O>> method(Message<I> msg) Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming Multi<O> method(I payload) Called once at assembly time PRE_PROCESSING , NONE automatic @Outgoing @Incoming PublisherBuilder<Message<O>> method(Message<I> msg) Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming PublisherBuilder<O> method(I payload) Called once at assembly time PRE_PROCESSING , NONE automatic Method signatures to process data Signature Invocation time Supported Acknowledgement Strategies Metadata Propagation @Outgoing @Incoming Publisher<Message<O>> method(Publisher<Message<I>> pub) Called once at assembly time MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming Publisher<O> method(Publisher<I> pub) Called once at assembly time PRE_PROCESSING , NONE not supported @Outgoing @Incoming Multi<Message<O>> method(Multi<Message<I>> pub) Called once at assembly time MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming Multi<O> method(Multi<I> pub) Called once at assembly time PRE_PROCESSING , NONE not supported @Outgoing @Incoming PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub) Called once at assembly time MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming PublisherBuilder<O> method(PublisherBuilder<I> pub) Called once at assembly time NONE, PRE_PROCESSING not supported Method signatures to manipulate streams Important When processing Message , it is often required to chain the incoming Message to enable post-processing acknowledgement and metadata propagation. Use the with (like withPayload ) methods from the incoming message, so it copies the metadata and ack/nack methods. It returns a new Message with the right content.","title":"Method Signatures"},{"location":"concepts/signatures/#supported-signatures","text":"The following tables list the supported method signatures and indicate the various supported features. For instance, they indicate the default and available acknowledgement strategies (when applicable). Signature Invocation time @Outgoing Publisher<Message<O>> method() ` Called once at assembly time @Outgoing Publisher<O> method() ` Called once at assembly time @Outgoing Multi<Message<O>> method() ` Called once at assembly time @Outgoing Multi<O> method() ` Called once at assembly time @Outgoing PublisherBuilder<Message<O>> method() ` Called once at assembly time @Outgoing PublisherBuilder<O> method() ` Called once at assembly time @Outgoing Message<O> method() ` Called for every downstream request, sequentially @Outgoing O method() ` Called for every downstream request, sequentially @Outgoing CompletionStage<Message<O>> method() ` Called for every downstream request, sequentially (After the completion of the last returned CompletionStage) @Outgoing CompletionStage<O> method() ` Called for every downstream request, , sequentially (After the completion of the last returned CompletionStage) @Outgoing Uni<Message<O>> method() ` Called for every downstream request, sequentially (After the completion of the last returned Uni) @Outgoing Uni<O> method() ` Called for every downstream request, , sequentially (After the completion of the last returned Uni) Method signatures to generate data Signature Invocation time Supported Acknowledgement Strategies @Incoming void method(I p) Called for every incoming payload (sequentially) POST_PROCESSING , NONE, PRE_PROCESSING @Incoming CompletionStage<?> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING @Incoming CompletionStage<?> method(I p) Called for every incoming payload (sequentially) POST_PROCESSING , PRE_PROCESSING, NONE @Incoming Uni<?> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING @Incoming Uni<?> method(I p) Called for every incoming payload (sequentially) POST_PROCESSING , PRE_PROCESSING, NONE @Incoming Subscriber<Message<I>> method() Called once at assembly time MANUAL , POST_PROCESSING, NONE, PRE_PROCESSING @Incoming Subscriber<I> method() Called once at assembly time POST_PROCESSING , NONE, PRE_PROCESSING Method signatures to consume data Signature Invocation time Supported Acknowledgement Strategies Metadata Propagation @Outgoing @Incoming Message<O> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming O method(I payload) Called for every incoming payload (sequentially) POST_PROCESSING , NONE, PRE_PROCESSING automatic @Outgoing @Incoming CompletionStage<Message<O>> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming CompletionStage<O> method(I payload) Called for every incoming payload (sequentially) POST_PROCESSING , NONE, PRE_PROCESSING automatic @Outgoing @Incoming Uni<Message<O>> method(Message<I> msg) Called for every incoming message (sequentially) MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming Uni<O> method(I payload) Called for every incoming payload (sequentially) POST_PROCESSING , NONE, PRE_PROCESSING automatic @Outgoing @Incoming Processor<Message<I>, Message<O>> method() Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming Processor<I, O> method() Called once at assembly time PRE_PROCESSING , NONE not supported @Outgoing @Incoming ProcessorBuilder<Message<I>, Message<O>> method() Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming ProcessorBuilder<I, O> method() Called once at assembly time PRE_PROCESSING , NONE not supported @Outgoing @Incoming Publisher<Message<O>> method(Message<I> msg) Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming Publisher<O> method(I payload) Called once at assembly time PRE_PROCESSING , NONE automatic @Outgoing @Incoming Multi<Message<O>> method(Message<I> msg) Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming Multi<O> method(I payload) Called once at assembly time PRE_PROCESSING , NONE automatic @Outgoing @Incoming PublisherBuilder<Message<O>> method(Message<I> msg) Called once at assembly time MANUAL , PRE_PROCESSING, NONE manual @Outgoing @Incoming PublisherBuilder<O> method(I payload) Called once at assembly time PRE_PROCESSING , NONE automatic Method signatures to process data Signature Invocation time Supported Acknowledgement Strategies Metadata Propagation @Outgoing @Incoming Publisher<Message<O>> method(Publisher<Message<I>> pub) Called once at assembly time MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming Publisher<O> method(Publisher<I> pub) Called once at assembly time PRE_PROCESSING , NONE not supported @Outgoing @Incoming Multi<Message<O>> method(Multi<Message<I>> pub) Called once at assembly time MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming Multi<O> method(Multi<I> pub) Called once at assembly time PRE_PROCESSING , NONE not supported @Outgoing @Incoming PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub) Called once at assembly time MANUAL , NONE, PRE_PROCESSING manual @Outgoing @Incoming PublisherBuilder<O> method(PublisherBuilder<I> pub) Called once at assembly time NONE, PRE_PROCESSING not supported Method signatures to manipulate streams Important When processing Message , it is often required to chain the incoming Message to enable post-processing acknowledgement and metadata propagation. Use the with (like withPayload ) methods from the incoming message, so it copies the metadata and ack/nack methods. It returns a new Message with the right content.","title":"Supported signatures"},{"location":"concepts/skipping/","text":"Skipping messages Sometimes you receive a message and don\u2019t want to produce an output message. To handle this, you have several choices: for method processing single message or payload, producing null would produce an ignored message (not forwarded) for method processing streams, you can generate an empty stream. Skipping a single item To skip a single message or payload, return null : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // Skip when processing payload synchronously - returning `null` @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public String processPayload ( String s ) { if ( s . equalsIgnoreCase ( \"skip\" )) { return null ; } return s . toUpperCase (); } // Skip when processing message synchronously - returning `null` @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Message < String > processMessage ( Message < String > m ) { String s = m . getPayload (); if ( s . equalsIgnoreCase ( \"skip\" )) { m . ack (); return null ; } return m . withPayload ( s . toUpperCase ()); } // Skip when processing payload asynchronously - returning a `Uni` with a `null` value @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Uni < String > processPayloadAsync ( String s ) { if ( s . equalsIgnoreCase ( \"skip\" )) { // Important, you must not return `null`, but a `null` content return Uni . createFrom (). nullItem (); } return Uni . createFrom (). item ( s . toUpperCase ()); } // Skip when processing message asynchronously - returning a `Uni` with a `null` value @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Uni < Message < String >> processMessageAsync ( Message < String > m ) { String s = m . getPayload (); if ( s . equalsIgnoreCase ( \"skip\" )) { m . ack (); return Uni . createFrom (). nullItem (); } return Uni . createFrom (). item ( m . withPayload ( s . toUpperCase ())); } Skipping in a stream To skip a message or payload when manipulating a stream, emit an empty Multi (or Publisher ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Incoming ( \"in\" ) @Outgoing ( \"out-1\" ) public Multi < String > processPayload ( String s ) { if ( s . equalsIgnoreCase ( \"skip\" )) { return Multi . createFrom (). empty (); } return Multi . createFrom (). item ( s . toUpperCase ()); } @Incoming ( \"in\" ) @Outgoing ( \"out-2\" ) public Multi < Message < String >> processMessage ( Message < String > m ) { String s = m . getPayload (); if ( s . equalsIgnoreCase ( \"skip\" )) { return Multi . createFrom (). empty (); } return Multi . createFrom (). item ( m . withPayload ( s . toUpperCase ())); } @Incoming ( \"in\" ) @Outgoing ( \"out-3\" ) public Multi < String > processPayloadStream ( Multi < String > stream ) { return stream . select (). where ( s -> ! s . equalsIgnoreCase ( \"skip\" )) . onItem (). transform ( String :: toUpperCase ); } @Incoming ( \"in\" ) @Outgoing ( \"out-4\" ) public Multi < Message < String >> processMessageStream ( Multi < Message < String >> stream ) { return stream . select (). where ( m -> ! m . getPayload (). equalsIgnoreCase ( \"skip\" )) . onItem (). transform ( m -> m . withPayload ( m . getPayload (). toUpperCase ())); }","title":"Skipping Messages"},{"location":"concepts/skipping/#skipping-messages","text":"Sometimes you receive a message and don\u2019t want to produce an output message. To handle this, you have several choices: for method processing single message or payload, producing null would produce an ignored message (not forwarded) for method processing streams, you can generate an empty stream.","title":"Skipping messages"},{"location":"concepts/skipping/#skipping-a-single-item","text":"To skip a single message or payload, return null : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // Skip when processing payload synchronously - returning `null` @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public String processPayload ( String s ) { if ( s . equalsIgnoreCase ( \"skip\" )) { return null ; } return s . toUpperCase (); } // Skip when processing message synchronously - returning `null` @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Message < String > processMessage ( Message < String > m ) { String s = m . getPayload (); if ( s . equalsIgnoreCase ( \"skip\" )) { m . ack (); return null ; } return m . withPayload ( s . toUpperCase ()); } // Skip when processing payload asynchronously - returning a `Uni` with a `null` value @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Uni < String > processPayloadAsync ( String s ) { if ( s . equalsIgnoreCase ( \"skip\" )) { // Important, you must not return `null`, but a `null` content return Uni . createFrom (). nullItem (); } return Uni . createFrom (). item ( s . toUpperCase ()); } // Skip when processing message asynchronously - returning a `Uni` with a `null` value @Incoming ( \"in\" ) @Outgoing ( \"out\" ) public Uni < Message < String >> processMessageAsync ( Message < String > m ) { String s = m . getPayload (); if ( s . equalsIgnoreCase ( \"skip\" )) { m . ack (); return Uni . createFrom (). nullItem (); } return Uni . createFrom (). item ( m . withPayload ( s . toUpperCase ())); }","title":"Skipping a single item"},{"location":"concepts/skipping/#skipping-in-a-stream","text":"To skip a message or payload when manipulating a stream, emit an empty Multi (or Publisher ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Incoming ( \"in\" ) @Outgoing ( \"out-1\" ) public Multi < String > processPayload ( String s ) { if ( s . equalsIgnoreCase ( \"skip\" )) { return Multi . createFrom (). empty (); } return Multi . createFrom (). item ( s . toUpperCase ()); } @Incoming ( \"in\" ) @Outgoing ( \"out-2\" ) public Multi < Message < String >> processMessage ( Message < String > m ) { String s = m . getPayload (); if ( s . equalsIgnoreCase ( \"skip\" )) { return Multi . createFrom (). empty (); } return Multi . createFrom (). item ( m . withPayload ( s . toUpperCase ())); } @Incoming ( \"in\" ) @Outgoing ( \"out-3\" ) public Multi < String > processPayloadStream ( Multi < String > stream ) { return stream . select (). where ( s -> ! s . equalsIgnoreCase ( \"skip\" )) . onItem (). transform ( String :: toUpperCase ); } @Incoming ( \"in\" ) @Outgoing ( \"out-4\" ) public Multi < Message < String >> processMessageStream ( Multi < Message < String >> stream ) { return stream . select (). where ( m -> ! m . getPayload (). equalsIgnoreCase ( \"skip\" )) . onItem (). transform ( m -> m . withPayload ( m . getPayload (). toUpperCase ())); }","title":"Skipping in a stream"},{"location":"concepts/testing/","text":"Testing your application It\u2019s not rare to have to test your application but deploying the infrastructure can be cumbersome. While Docker or Test Containers have improved the testing experience, you may want to mock this infrastructure. SmallRye Reactive Messaging proposes an in-memory connector for this exact purpose. It allows switching the connector used for a channel with an in-memory connector. This in-memory connector provides a way to send messages to incoming channels, or check the received messages for outgoing channels. To use the in-memory connector, you need to add the following dependency to your project: 1 2 3 4 5 6 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-in-memory </artifactId> <version> 3.14.0-SNAPSHOT </version> <scope> test </scope> </dependency> Then, in a test, you can do something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package testing ; import javax.enterprise.inject.Any ; import javax.inject.Inject ; import org.junit.jupiter.api.AfterAll ; import org.junit.jupiter.api.Assertions ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.Test ; import io.smallrye.reactive.messaging.providers.connectors.InMemoryConnector ; import io.smallrye.reactive.messaging.providers.connectors.InMemorySink ; import io.smallrye.reactive.messaging.providers.connectors.InMemorySource ; public class MyTest { // 1. Switch the channels to the in-memory connector: @BeforeAll public static void switchMyChannels () { InMemoryConnector . switchIncomingChannelsToInMemory ( \"prices\" ); InMemoryConnector . switchOutgoingChannelsToInMemory ( \"processed-prices\" ); } // 2. Don't forget to reset the channel after the tests: @AfterAll public static void revertMyChannels () { InMemoryConnector . clear (); } // 3. Inject the in-memory connector in your test, // or use the bean manager to retrieve the instance @Inject @Any InMemoryConnector connector ; @Test void test () { // 4. Retrieves the in-memory source to send message InMemorySource < Integer > prices = connector . source ( \"prices\" ); // 5. Retrieves the in-memory sink to check what is received InMemorySink < Integer > results = connector . sink ( \"processed-prices\" ); // 6. Send fake messages: prices . send ( 1 ); prices . send ( 2 ); prices . send ( 3 ); // 7. Check you have receives the expected messages Assertions . assertEquals ( 3 , results . received (). size ()); } } When switching a channel to the in-memory connector, all the configuration properties are ignored. Important This connector has been designed for testing purpose only. The switch methods return Map<String, String> instances containing the set properties. While these system properties are already set, you can retrieve them and pass them around, for example if you need to start an external process with these properties: 1 2 3 4 5 6 7 8 9 10 public Map < String , String > start () { Map < String , String > env = new HashMap <> (); env . putAll ( InMemoryConnector . switchIncomingChannelsToInMemory ( \"prices\" )); env . putAll ( InMemoryConnector . switchOutgoingChannelsToInMemory ( \"my-data-stream\" )); return env ; } public void stop () { InMemoryConnector . clear (); } Note The in-memory connector support the broadcast and merge attributes. So, if your connector is configured with broadcast: true , the connector broadcasts the messages to all the channel consumers. If your connector is configured with merge:true , the connector receives all the messages sent to the mapped channel even when coming from multiple producers.","title":"Testing"},{"location":"concepts/testing/#testing-your-application","text":"It\u2019s not rare to have to test your application but deploying the infrastructure can be cumbersome. While Docker or Test Containers have improved the testing experience, you may want to mock this infrastructure. SmallRye Reactive Messaging proposes an in-memory connector for this exact purpose. It allows switching the connector used for a channel with an in-memory connector. This in-memory connector provides a way to send messages to incoming channels, or check the received messages for outgoing channels. To use the in-memory connector, you need to add the following dependency to your project: 1 2 3 4 5 6 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-in-memory </artifactId> <version> 3.14.0-SNAPSHOT </version> <scope> test </scope> </dependency> Then, in a test, you can do something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package testing ; import javax.enterprise.inject.Any ; import javax.inject.Inject ; import org.junit.jupiter.api.AfterAll ; import org.junit.jupiter.api.Assertions ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.Test ; import io.smallrye.reactive.messaging.providers.connectors.InMemoryConnector ; import io.smallrye.reactive.messaging.providers.connectors.InMemorySink ; import io.smallrye.reactive.messaging.providers.connectors.InMemorySource ; public class MyTest { // 1. Switch the channels to the in-memory connector: @BeforeAll public static void switchMyChannels () { InMemoryConnector . switchIncomingChannelsToInMemory ( \"prices\" ); InMemoryConnector . switchOutgoingChannelsToInMemory ( \"processed-prices\" ); } // 2. Don't forget to reset the channel after the tests: @AfterAll public static void revertMyChannels () { InMemoryConnector . clear (); } // 3. Inject the in-memory connector in your test, // or use the bean manager to retrieve the instance @Inject @Any InMemoryConnector connector ; @Test void test () { // 4. Retrieves the in-memory source to send message InMemorySource < Integer > prices = connector . source ( \"prices\" ); // 5. Retrieves the in-memory sink to check what is received InMemorySink < Integer > results = connector . sink ( \"processed-prices\" ); // 6. Send fake messages: prices . send ( 1 ); prices . send ( 2 ); prices . send ( 3 ); // 7. Check you have receives the expected messages Assertions . assertEquals ( 3 , results . received (). size ()); } } When switching a channel to the in-memory connector, all the configuration properties are ignored. Important This connector has been designed for testing purpose only. The switch methods return Map<String, String> instances containing the set properties. While these system properties are already set, you can retrieve them and pass them around, for example if you need to start an external process with these properties: 1 2 3 4 5 6 7 8 9 10 public Map < String , String > start () { Map < String , String > env = new HashMap <> (); env . putAll ( InMemoryConnector . switchIncomingChannelsToInMemory ( \"prices\" )); env . putAll ( InMemoryConnector . switchOutgoingChannelsToInMemory ( \"my-data-stream\" )); return env ; } public void stop () { InMemoryConnector . clear (); } Note The in-memory connector support the broadcast and merge attributes. So, if your connector is configured with broadcast: true , the connector broadcasts the messages to all the channel consumers. If your connector is configured with merge:true , the connector receives all the messages sent to the mapped channel even when coming from multiple producers.","title":"Testing your application"},{"location":"connectors/smallrye-camel-incoming/","text":"Attribute ( alias ) Description Type Mandatory Default endpoint-uri The URI of the Camel endpoint (read from or written to) string true failure-strategy Specify the failure strategy to apply when a message produced from a Camel exchange is nacked. Values can be fail (default) or ignore string false fail","title":"Smallrye camel incoming"},{"location":"connectors/smallrye-camel-outgoing/","text":"Attribute ( alias ) Description Type Mandatory Default endpoint-uri The URI of the Camel endpoint (read from or written to) string true merge Whether the connector should allow multiple upstreams boolean false false","title":"Smallrye camel outgoing"},{"location":"connectors/smallrye-jms-incoming/","text":"Attribute ( alias ) Description Type Mandatory Default broadcast Whether or not the JMS message should be dispatched to multiple consumers boolean false false client-id The client id String false connection-factory-name The name of the JMS connection factory ( javax.jms.ConnectionFactory ) to be used. If not set, it uses any exposed JMS connection factory String false destination The name of the JMS destination. If not set the name of the channel is used String false destination-type The type of destination. It can be either queue or topic string false queue durable Set to true to use a durable subscription boolean false false no-local Enable or disable local delivery boolean false false password The password to connect to to the JMS server String false selector The JMS selector String false session-mode The session mode. Accepted values are AUTO_ACKNOWLEDGE, SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE String false AUTO_ACKNOWLEDGE username The username to connect to to the JMS server String false","title":"Smallrye jms incoming"},{"location":"connectors/smallrye-jms-outgoing/","text":"Attribute ( alias ) Description Type Mandatory Default client-id The client id String false connection-factory-name The name of the JMS connection factory ( javax.jms.ConnectionFactory ) to be used. If not set, it uses any exposed JMS connection factory String false correlation-id The JMS Message correlation id string false delivery-delay The delivery delay long false delivery-mode The delivery mode. Either persistent or non_persistent string false destination The name of the JMS destination. If not set the name of the channel is used String false destination-type The type of destination. It can be either queue or topic string false queue disable-message-id Omit the message id in the outbound JMS message boolean false disable-message-timestamp Omit the message timestamp in the outbound JMS message boolean false merge Whether the connector should allow multiple upstreams boolean false false password The password to connect to to the JMS server String false priority The JMS Message priority int false reply-to The reply to destination if any string false reply-to-destination-type The type of destination for the response. It can be either queue or topic string false queue session-mode The session mode. Accepted values are AUTO_ACKNOWLEDGE, SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE String false AUTO_ACKNOWLEDGE ttl The JMS Message time-to-live long false username The username to connect to to the JMS server String false","title":"Smallrye jms outgoing"},{"location":"connectors/smallrye-mqtt-incoming/","text":"Attribute ( alias ) Description Type Mandatory Default auto-clean-session Set to start with a clean session ( true by default) boolean false true auto-generated-client-id Set if the MQTT client must generate clientId automatically boolean false true auto-keep-alive Set if the MQTT client must handle PINGREQ automatically boolean false true broadcast Whether or not the messages should be dispatched to multiple consumers boolean false false client-id Set the client identifier string false connect-timeout-seconds Set the connect timeout (in seconds) int false 60 failure-strategy Specify the failure strategy to apply when a message produced from a MQTT message is nacked. Values can be fail (default), or ignore string false fail host Set the MQTT server host name/IP string true keep-alive-seconds Set the keep alive timeout in seconds int false 30 max-inflight-queue Set max count of unacknowledged messages int false 10 max-message-size Set max MQTT message size in bytes int false 8092 password Set the password to connect to the server string false port Set the MQTT server port. Default to 8883 if ssl is enabled, or 1883 without ssl int false qos Set the QoS level when subscribing to the topic or when sending a message int false 0 reconnect-interval-seconds Set the reconnect interval in seconds int false 1 server-name Set the SNI server name string false ssl Set whether SSL/TLS is enabled boolean false false ssl.keystore.location Set the keystore location. In case of pem type this is the cert path string false ssl.keystore.password Set the keystore password. In case of pem type this is the key path string false ssl.keystore.type Set the keystore type [ pkcs12 , jks , pem ] string false pkcs12 ssl.truststore.location Set the truststore location. In case of pem type this is the cert path string false ssl.truststore.password Set the truststore password. In case of pem type this is not necessary string false ssl.truststore.type Set the truststore type string false pkcs12 topic Set the MQTT topic. If not set, the channel name is used string false trust-all Set whether all server certificates should be trusted boolean false false username Set the username to connect to the server string false will-flag Set if will information are provided on connection boolean false false will-qos Set the QoS level for the will message int false 0 will-retain Set if the will message must be retained boolean false false","title":"Smallrye mqtt incoming"},{"location":"connectors/smallrye-mqtt-outgoing/","text":"Attribute ( alias ) Description Type Mandatory Default auto-clean-session Set to start with a clean session ( true by default) boolean false true auto-generated-client-id Set if the MQTT client must generate clientId automatically boolean false true auto-keep-alive Set if the MQTT client must handle PINGREQ automatically boolean false true client-id Set the client identifier string false connect-timeout-seconds Set the connect timeout (in seconds) int false 60 host Set the MQTT server host name/IP string true keep-alive-seconds Set the keep alive timeout in seconds int false 30 max-inflight-queue Set max count of unacknowledged messages int false 10 max-message-size Set max MQTT message size in bytes int false 8092 merge Whether the connector should allow multiple upstreams boolean false false password Set the password to connect to the server string false port Set the MQTT server port. Default to 8883 if ssl is enabled, or 1883 without ssl int false qos Set the QoS level when subscribing to the topic or when sending a message int false 0 reconnect-interval-seconds Set the reconnect interval in seconds int false 1 server-name Set the SNI server name string false ssl Set whether SSL/TLS is enabled boolean false false ssl.keystore.location Set the keystore location. In case of pem type this is the cert path string false ssl.keystore.password Set the keystore password. In case of pem type this is the key path string false ssl.keystore.type Set the keystore type [ pkcs12 , jks , pem ] string false pkcs12 ssl.truststore.location Set the truststore location. In case of pem type this is the cert path string false ssl.truststore.password Set the truststore password. In case of pem type this is not necessary string false ssl.truststore.type Set the truststore type string false pkcs12 topic Set the MQTT topic. If not set, the channel name is used string false trust-all Set whether all server certificates should be trusted boolean false false username Set the username to connect to the server string false will-flag Set if will information are provided on connection boolean false false will-qos Set the QoS level for the will message int false 0 will-retain Set if the will message must be retained boolean false false","title":"Smallrye mqtt outgoing"},{"location":"connectors/smallrye-rabbitmq-incoming/","text":"Attribute ( alias ) Description Type Mandatory Default auto-acknowledgement Whether the received RabbitMQ messages must be acknowledged when received; if true then delivery constitutes acknowledgement boolean false false auto-bind-dlq Whether to automatically declare the DLQ and bind it to the binder DLX boolean false false automatic-recovery-enabled Whether automatic connection recovery is enabled boolean false false automatic-recovery-on-initial-connection Whether automatic recovery on initial connections is enabled boolean false true broadcast Whether the received RabbitMQ messages must be dispatched to multiple subscribers boolean false false client-options-name (rabbitmq-client-options-name) The name of the RabbitMQ Client Option bean used to customize the RabbitMQ client configuration string false connection-timeout The TCP connection timeout (ms); 0 is interpreted as no timeout int false 60000 credentials-provider-name (rabbitmq-credentials-provider-name) The name of the RabbitMQ Credentials Provider bean used to provide dynamic credentials to the RabbitMQ client string false dead-letter-exchange A DLX to assign to the queue. Relevant only if auto-bind-dlq is true string false DLX dead-letter-exchange-type The type of the DLX to assign to the queue. Relevant only if auto-bind-dlq is true string false direct dead-letter-queue-name The name of the DLQ; if not supplied will default to the queue name with '.dlq' appended string false dead-letter-routing-key A dead letter routing key to assign to the queue; if not supplied will default to the queue name string false dlx.declare Whether to declare the dead letter exchange binding. Relevant only if auto-bind-dlq is true; set to false if these are expected to be set up independently boolean false false exchange.auto-delete Whether the exchange should be deleted after use boolean false false exchange.declare Whether to declare the exchange; set to false if the exchange is expected to be set up independently boolean false true exchange.durable Whether the exchange is durable boolean false true exchange.name The exchange that messages are published to or consumed from. If not set, the channel name is used string false exchange.type The exchange type: direct, fanout, headers or topic (default) string false topic failure-strategy The failure strategy to apply when a RabbitMQ message is nacked. Accepted values are fail , accept , reject (default) string false reject handshake-timeout The AMQP 0-9-1 protocol handshake timeout (ms) int false 10000 host (rabbitmq-host) The broker hostname string false localhost include-properties Whether to include properties when a broker message is passed on the event bus boolean false false keep-most-recent Whether to discard old messages instead of recent ones boolean false false max-incoming-internal-queue-size The maximum size of the incoming internal queue int false network-recovery-interval How long (ms) will automatic recovery wait before attempting to reconnect int false 5000 password (rabbitmq-password) The password used to authenticate to the broker string false port (rabbitmq-port) The broker port int false 5672 queue.auto-delete Whether the queue should be deleted after use boolean false false queue.declare Whether to declare the queue and binding; set to false if these are expected to be set up independently boolean false true queue.durable Whether the queue is durable boolean false true queue.exclusive Whether the queue is for exclusive use boolean false false queue.name The queue from which messages are consumed. string true queue.ttl If specified, the time (ms) for which a message can remain in the queue undelivered before it is dead long false reconnect-attempts (rabbitmq-reconnect-attempts) The number of reconnection attempts int false 100 reconnect-interval (rabbitmq-reconnect-interval) The interval (in seconds) between two reconnection attempts int false 10 requested-channel-max The initially requested maximum channel number int false 2047 requested-heartbeat The initially requested heartbeat interval (seconds), zero for none int false 60 routing-keys A comma-separated list of routing keys to bind the queue to the exchange string false # ssl (rabbitmq-ssl) Whether or not the connection should use SSL boolean false false tracing.attribute-headers A comma-separated list of headers that should be recorded as span attributes. Relevant only if tracing.enabled=true string false `` tracing.enabled Whether tracing is enabled (default) or disabled boolean false true trust-all (rabbitmq-trust-all) Whether to skip trust certificate verification boolean false false trust-store-password (rabbitmq-trust-store-password) The password of the JKS trust store string false trust-store-path (rabbitmq-trust-store-path) The path to a JKS trust store string false use-nio Whether usage of NIO Sockets is enabled boolean false false user The user name to use when connecting to the broker string false guest username (rabbitmq-username) The username used to authenticate to the broker string false virtual-host (rabbitmq-virtual-host) The virtual host to use when connecting to the broker string false /","title":"Smallrye rabbitmq incoming"},{"location":"connectors/smallrye-rabbitmq-outgoing/","text":"Attribute ( alias ) Description Type Mandatory Default automatic-recovery-enabled Whether automatic connection recovery is enabled boolean false false automatic-recovery-on-initial-connection Whether automatic recovery on initial connections is enabled boolean false true client-options-name (rabbitmq-client-options-name) The name of the RabbitMQ Client Option bean used to customize the RabbitMQ client configuration string false connection-timeout The TCP connection timeout (ms); 0 is interpreted as no timeout int false 60000 credentials-provider-name (rabbitmq-credentials-provider-name) The name of the RabbitMQ Credentials Provider bean used to provide dynamic credentials to the RabbitMQ client string false default-routing-key The default routing key to use when sending messages to the exchange string false `` default-ttl If specified, the time (ms) sent messages can remain in queues undelivered before they are dead long false exchange.auto-delete Whether the exchange should be deleted after use boolean false false exchange.declare Whether to declare the exchange; set to false if the exchange is expected to be set up independently boolean false true exchange.durable Whether the exchange is durable boolean false true exchange.name The exchange that messages are published to or consumed from. If not set, the channel name is used string false exchange.type The exchange type: direct, fanout, headers or topic (default) string false topic handshake-timeout The AMQP 0-9-1 protocol handshake timeout (ms) int false 10000 host (rabbitmq-host) The broker hostname string false localhost include-properties Whether to include properties when a broker message is passed on the event bus boolean false false max-inflight-messages The maximum number of messages to be written to RabbitMQ concurrently; must be a positive number long false 1024 max-outgoing-internal-queue-size The maximum size of the outgoing internal queue int false network-recovery-interval How long (ms) will automatic recovery wait before attempting to reconnect int false 5000 password (rabbitmq-password) The password used to authenticate to the broker string false port (rabbitmq-port) The broker port int false 5672 reconnect-attempts (rabbitmq-reconnect-attempts) The number of reconnection attempts int false 100 reconnect-interval (rabbitmq-reconnect-interval) The interval (in seconds) between two reconnection attempts int false 10 requested-channel-max The initially requested maximum channel number int false 2047 requested-heartbeat The initially requested heartbeat interval (seconds), zero for none int false 60 ssl (rabbitmq-ssl) Whether or not the connection should use SSL boolean false false tracing.attribute-headers A comma-separated list of headers that should be recorded as span attributes. Relevant only if tracing.enabled=true string false `` tracing.enabled Whether tracing is enabled (default) or disabled boolean false true trust-all (rabbitmq-trust-all) Whether to skip trust certificate verification boolean false false trust-store-password (rabbitmq-trust-store-password) The password of the JKS trust store string false trust-store-path (rabbitmq-trust-store-path) The path to a JKS trust store string false use-nio Whether usage of NIO Sockets is enabled boolean false false user The user name to use when connecting to the broker string false guest username (rabbitmq-username) The username used to authenticate to the broker string false virtual-host (rabbitmq-virtual-host) The virtual host to use when connecting to the broker string false /","title":"Smallrye rabbitmq outgoing"},{"location":"jms/advanced-jms/","text":"Advanced configuration Underlying thread pool Lots of JMS operations are blocking and so not cannot be done on the caller thread. For this reason, these blocking operations are executed on a worker thread. You can configure the thread pool providing these worker threads using the following MicroProfile Config properties: smallrye.jms.threads.max-pool-size - the max number of threads (Defaults to 10) smallrye.jms.threads.ttl - the ttl of the created threads (Defaults to 60 seconds) Selecting the ConnectionFactory The JMS Connector requires a javax.jms.ConnectionFactory to be exposed as a CDI bean. The connector looks for a javax.jms.ConnectionFactory and delegate the interaction with the JMS server to this factory. In case you have several connection factories, you can use the @Identifier qualifier on your factory to specify the name. Then, in the channel configuration, configure the name as follows: 1 2 3 4 5 6 # Configure the connector globally mp.messaging.connector.smallrye-jms.connection-factory-name = my-factory-name # Configure a specific incoming channel mp.messaging.incoming.my-channel.connection-factory-name = my-factory-name # Configure a specific outgoing channel mp.messaging.outgoing.my-channel.connection-factory-name = my-factory-name","title":"Advanced configuration"},{"location":"jms/advanced-jms/#advanced-configuration","text":"","title":"Advanced configuration"},{"location":"jms/advanced-jms/#underlying-thread-pool","text":"Lots of JMS operations are blocking and so not cannot be done on the caller thread. For this reason, these blocking operations are executed on a worker thread. You can configure the thread pool providing these worker threads using the following MicroProfile Config properties: smallrye.jms.threads.max-pool-size - the max number of threads (Defaults to 10) smallrye.jms.threads.ttl - the ttl of the created threads (Defaults to 60 seconds)","title":"Underlying thread pool"},{"location":"jms/advanced-jms/#selecting-the-connectionfactory","text":"The JMS Connector requires a javax.jms.ConnectionFactory to be exposed as a CDI bean. The connector looks for a javax.jms.ConnectionFactory and delegate the interaction with the JMS server to this factory. In case you have several connection factories, you can use the @Identifier qualifier on your factory to specify the name. Then, in the channel configuration, configure the name as follows: 1 2 3 4 5 6 # Configure the connector globally mp.messaging.connector.smallrye-jms.connection-factory-name = my-factory-name # Configure a specific incoming channel mp.messaging.incoming.my-channel.connection-factory-name = my-factory-name # Configure a specific outgoing channel mp.messaging.outgoing.my-channel.connection-factory-name = my-factory-name","title":"Selecting the ConnectionFactory"},{"location":"jms/jms/","text":"The JMS connector The JMS connector adds support for Jakarta Messaging to Reactive Messaging. It is designed to integrate with JakartaEE applications that are sending or receiving Jakarta Messaging Messages. Jakarta Messaging is a Java Message Oriented Middleware API for sending messages between two or more clients. It is a programming model to handle the producer-consumer messaging problem. It is a messaging standard that allows application components based on Jakarta EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. Using the JMS connector To you the JMS Connector, add the following dependency to your project: 1 2 3 4 5 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-jms </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> The connector name is: smallrye-jms . So, to indicate that a channel is managed by this connector you need: 1 2 3 4 5 # Inbound mp.messaging.incoming.[channel-name].connector = smallrye-jms # Outbound mp.messaging.outgoing.[channel-name].connector = smallrye-jms The JMS Connector requires a javax.jms.ConnectionFactory to be exposed (as CDI bean). The connector looks for a javax.jms.ConnectionFactory and delegate the interaction with the JMS server to this factory. In other words, it creates the JMS connection and context using this factory. So, in order to use this connector you would need to expose a javax.jms.ConnectionFactory : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import javax.enterprise.context.ApplicationScoped ; import javax.enterprise.inject.Produces ; import javax.jms.ConnectionFactory ; import org.apache.activemq.artemis.jms.client.ActiveMQJMSConnectionFactory ; @ApplicationScoped public class ConnectionFactoryBean { @Produces ConnectionFactory factory () { return new ActiveMQJMSConnectionFactory ( \"tcp://localhost:61616\" , null , null ); } } The factory class may depend on your JMS connector/server.","title":"The JMS connector"},{"location":"jms/jms/#the-jms-connector","text":"The JMS connector adds support for Jakarta Messaging to Reactive Messaging. It is designed to integrate with JakartaEE applications that are sending or receiving Jakarta Messaging Messages. Jakarta Messaging is a Java Message Oriented Middleware API for sending messages between two or more clients. It is a programming model to handle the producer-consumer messaging problem. It is a messaging standard that allows application components based on Jakarta EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous.","title":"The JMS connector"},{"location":"jms/jms/#using-the-jms-connector","text":"To you the JMS Connector, add the following dependency to your project: 1 2 3 4 5 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-jms </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> The connector name is: smallrye-jms . So, to indicate that a channel is managed by this connector you need: 1 2 3 4 5 # Inbound mp.messaging.incoming.[channel-name].connector = smallrye-jms # Outbound mp.messaging.outgoing.[channel-name].connector = smallrye-jms The JMS Connector requires a javax.jms.ConnectionFactory to be exposed (as CDI bean). The connector looks for a javax.jms.ConnectionFactory and delegate the interaction with the JMS server to this factory. In other words, it creates the JMS connection and context using this factory. So, in order to use this connector you would need to expose a javax.jms.ConnectionFactory : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import javax.enterprise.context.ApplicationScoped ; import javax.enterprise.inject.Produces ; import javax.jms.ConnectionFactory ; import org.apache.activemq.artemis.jms.client.ActiveMQJMSConnectionFactory ; @ApplicationScoped public class ConnectionFactoryBean { @Produces ConnectionFactory factory () { return new ActiveMQJMSConnectionFactory ( \"tcp://localhost:61616\" , null , null ); } } The factory class may depend on your JMS connector/server.","title":"Using the JMS connector"},{"location":"jms/receiving-jms-messages/","text":"Receiving messages from JMS The JMS Connector retrieves JMS Message and maps each of them into Reactive Messaging Messages . Example Let\u2019s imagine you have a javax.jms.ConnectionFactory bean exposed and connected to your JMS server. Don\u2019t forget that it\u2019s required to use the JMS connector. Configure your application to receive JMS messages on the prices channel as follows: 1 mp.messaging.incoming.prices.connector = smallrye-jms Note You don\u2019t need to set the destination. By default, it uses the channel name ( prices ). You can configure the destination attribute to override it. Note By default the connector uses a queue . You can configure it to use a topic by setting destination-type=topic . Then, your application receives Message<Double> . You can consume the payload directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package jms.inbound ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; @ApplicationScoped public class JmsPriceConsumer { @Incoming ( \"prices\" ) public void consume ( double price ) { // process your price. } } Or, you can retrieve the Message<Double> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package jms.inbound ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; @ApplicationScoped public class JmsPriceMessageConsumer { @Incoming ( \"prices\" ) public CompletionStage < Void > consume ( Message < Double > price ) { // process your price. // Acknowledge the incoming message return price . ack (); } } Deserialization The content of the incoming JMS message is mapped to a Java object. By default it extracts the JMS Message body as a java.lang.Object . This can be changed by setting, in the incoming JMS Message: The _classname property the JMSType The value must be a fully qualified class name. The connector then load the associated class. Note The connector loads the associated Class using the TCCL and if not found, the classloader used to load the connector. If the target type is a primitive type ort String , the resulting message contains the mapped payload. If the target type is a class, the object is built using included JSON deserializer (JSON-B and Jackson provided OOB, for more details see Serde ), from the JMSType . If not, the default behavior is used (Java deserialization). Inbound Metadata Messages coming from JMS contains an instance of io.smallrye.reactive.messaging.jms.IncomingJmsMessageMetadata in the metadata. 1 2 3 4 5 6 Optional < IncomingJmsMessageMetadata > metadata = incoming . getMetadata ( IncomingJmsMessageMetadata . class ); metadata . ifPresent ( meta -> { long expiration = meta . getExpiration (); Destination destination = meta . getDestination (); String value = meta . getStringProperty ( \"my-property\" ); }); Acknowledgement When the Reactive Messaging Message gets acknowledged, the associated JMS Message is acknowledged. As JMS acknowledgement is blocking, this acknowledgement is delegated to a worker thread. Configuration Reference Attribute ( alias ) Description Type Mandatory Default broadcast Whether or not the JMS message should be dispatched to multiple consumers boolean false false client-id The client id String false connection-factory-name The name of the JMS connection factory ( javax.jms.ConnectionFactory ) to be used. If not set, it uses any exposed JMS connection factory String false destination The name of the JMS destination. If not set the name of the channel is used String false destination-type The type of destination. It can be either queue or topic string false queue durable Set to true to use a durable subscription boolean false false no-local Enable or disable local delivery boolean false false password The password to connect to to the JMS server String false selector The JMS selector String false session-mode The session mode. Accepted values are AUTO_ACKNOWLEDGE, SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE String false AUTO_ACKNOWLEDGE username The username to connect to to the JMS server String false","title":"Receiving JMS messages"},{"location":"jms/receiving-jms-messages/#receiving-messages-from-jms","text":"The JMS Connector retrieves JMS Message and maps each of them into Reactive Messaging Messages .","title":"Receiving messages from JMS"},{"location":"jms/receiving-jms-messages/#example","text":"Let\u2019s imagine you have a javax.jms.ConnectionFactory bean exposed and connected to your JMS server. Don\u2019t forget that it\u2019s required to use the JMS connector. Configure your application to receive JMS messages on the prices channel as follows: 1 mp.messaging.incoming.prices.connector = smallrye-jms Note You don\u2019t need to set the destination. By default, it uses the channel name ( prices ). You can configure the destination attribute to override it. Note By default the connector uses a queue . You can configure it to use a topic by setting destination-type=topic . Then, your application receives Message<Double> . You can consume the payload directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package jms.inbound ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; @ApplicationScoped public class JmsPriceConsumer { @Incoming ( \"prices\" ) public void consume ( double price ) { // process your price. } } Or, you can retrieve the Message<Double> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package jms.inbound ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; @ApplicationScoped public class JmsPriceMessageConsumer { @Incoming ( \"prices\" ) public CompletionStage < Void > consume ( Message < Double > price ) { // process your price. // Acknowledge the incoming message return price . ack (); } }","title":"Example"},{"location":"jms/receiving-jms-messages/#deserialization","text":"The content of the incoming JMS message is mapped to a Java object. By default it extracts the JMS Message body as a java.lang.Object . This can be changed by setting, in the incoming JMS Message: The _classname property the JMSType The value must be a fully qualified class name. The connector then load the associated class. Note The connector loads the associated Class using the TCCL and if not found, the classloader used to load the connector. If the target type is a primitive type ort String , the resulting message contains the mapped payload. If the target type is a class, the object is built using included JSON deserializer (JSON-B and Jackson provided OOB, for more details see Serde ), from the JMSType . If not, the default behavior is used (Java deserialization).","title":"Deserialization"},{"location":"jms/receiving-jms-messages/#inbound-metadata","text":"Messages coming from JMS contains an instance of io.smallrye.reactive.messaging.jms.IncomingJmsMessageMetadata in the metadata. 1 2 3 4 5 6 Optional < IncomingJmsMessageMetadata > metadata = incoming . getMetadata ( IncomingJmsMessageMetadata . class ); metadata . ifPresent ( meta -> { long expiration = meta . getExpiration (); Destination destination = meta . getDestination (); String value = meta . getStringProperty ( \"my-property\" ); });","title":"Inbound Metadata"},{"location":"jms/receiving-jms-messages/#acknowledgement","text":"When the Reactive Messaging Message gets acknowledged, the associated JMS Message is acknowledged. As JMS acknowledgement is blocking, this acknowledgement is delegated to a worker thread.","title":"Acknowledgement"},{"location":"jms/receiving-jms-messages/#configuration-reference","text":"Attribute ( alias ) Description Type Mandatory Default broadcast Whether or not the JMS message should be dispatched to multiple consumers boolean false false client-id The client id String false connection-factory-name The name of the JMS connection factory ( javax.jms.ConnectionFactory ) to be used. If not set, it uses any exposed JMS connection factory String false destination The name of the JMS destination. If not set the name of the channel is used String false destination-type The type of destination. It can be either queue or topic string false queue durable Set to true to use a durable subscription boolean false false no-local Enable or disable local delivery boolean false false password The password to connect to to the JMS server String false selector The JMS selector String false session-mode The session mode. Accepted values are AUTO_ACKNOWLEDGE, SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE String false AUTO_ACKNOWLEDGE username The username to connect to to the JMS server String false","title":"Configuration Reference"},{"location":"jms/sending-jms-messages/","text":"Sending messages to JMS The JMS Connector can send Reactive Messaging Messages as JMS Message. Example Let\u2019s imagine you have a javax.jms.ConnectionFactory bean exposed and connected to your JMS server. Don\u2019t forget that it\u2019s required to use the JMS connector. Configure your application to write the messages from the prices channel into a JMS Message as follows: 1 mp.messaging.outgoing.prices.connector = smallrye-jms Note You don\u2019t need to set the destination. By default, it uses the channel name ( prices ). You can configure the destination attribute to override it. Note By default the connector uses a queue . You can configure it to use a topic by setting destination-type=topic . Then, your application must send Message<Double> to the prices channel. It can use double payloads as in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package jms.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class JmsPriceProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Double > generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()); } } Or, you can send Message<Double> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package jms.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class JmsPriceMessageProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Message < Double >> generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> Message . of ( random . nextDouble ())); } } Serialization The connector serializes the incoming message payload into the body of the outgoing JMS Message. If the payload is a String or a primitive type, the payload is encoded as String and the JMSType is set to the target class. The _classname property is also set. The JMS Message is a TextMessage . If the payload is a byte[] , it\u2019s passed as byte[] in a JMS BytesMessage . Otherwise, the payload is encoded using included JSON serializer (JSON-B and Jackson provided OOB, for more details see Serde ). The JMSType is set to the target class. The _classname property is also set. The JMS Message is a TextMessage . For example, the following code serialize the produced Person using JSON-B. 1 2 3 4 5 6 @Incoming ( \"...\" ) @Outgoing ( \"my-channel\" ) public Person sendToJms (...) { // ... return new Person ( \"bob\" , 42 ); } It requires that the Person class can be serialized to JSON. The classname is passed in the JMSType property and _classname property. Outbound Metadata When sending Messages , you can add an instance of OutgoingJmsMessageMetadata to influence how the message is going to written to JMS. 1 2 3 4 5 6 7 OutgoingJmsMessageMetadata metadata = OutgoingJmsMessageMetadata . builder () . withProperties ( JmsProperties . builder (). with ( \"some-property\" , \"some-value\" ). build ()) . build (); // Create a new message from the `incoming` message // Add `metadata` to the metadata from the `incoming` message. return incoming . addMetadata ( metadata ); The metadata allow adding properties but also override the destination. Acknowledgement Once the JMS message is sent to the JMS server, the message is acknowledged. Sending a JMS message is a blocking operation. So, sending is done on a worker thread. Configuration Reference Attribute ( alias ) Description Type Mandatory Default client-id The client id String false connection-factory-name The name of the JMS connection factory ( javax.jms.ConnectionFactory ) to be used. If not set, it uses any exposed JMS connection factory String false correlation-id The JMS Message correlation id string false delivery-delay The delivery delay long false delivery-mode The delivery mode. Either persistent or non_persistent string false destination The name of the JMS destination. If not set the name of the channel is used String false destination-type The type of destination. It can be either queue or topic string false queue disable-message-id Omit the message id in the outbound JMS message boolean false disable-message-timestamp Omit the message timestamp in the outbound JMS message boolean false merge Whether the connector should allow multiple upstreams boolean false false password The password to connect to to the JMS server String false priority The JMS Message priority int false reply-to The reply to destination if any string false reply-to-destination-type The type of destination for the response. It can be either queue or topic string false queue session-mode The session mode. Accepted values are AUTO_ACKNOWLEDGE, SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE String false AUTO_ACKNOWLEDGE ttl The JMS Message time-to-live long false username The username to connect to to the JMS server String false","title":"Sending JMS messages"},{"location":"jms/sending-jms-messages/#sending-messages-to-jms","text":"The JMS Connector can send Reactive Messaging Messages as JMS Message.","title":"Sending messages to JMS"},{"location":"jms/sending-jms-messages/#example","text":"Let\u2019s imagine you have a javax.jms.ConnectionFactory bean exposed and connected to your JMS server. Don\u2019t forget that it\u2019s required to use the JMS connector. Configure your application to write the messages from the prices channel into a JMS Message as follows: 1 mp.messaging.outgoing.prices.connector = smallrye-jms Note You don\u2019t need to set the destination. By default, it uses the channel name ( prices ). You can configure the destination attribute to override it. Note By default the connector uses a queue . You can configure it to use a topic by setting destination-type=topic . Then, your application must send Message<Double> to the prices channel. It can use double payloads as in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package jms.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class JmsPriceProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Double > generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()); } } Or, you can send Message<Double> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package jms.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class JmsPriceMessageProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Message < Double >> generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> Message . of ( random . nextDouble ())); } }","title":"Example"},{"location":"jms/sending-jms-messages/#serialization","text":"The connector serializes the incoming message payload into the body of the outgoing JMS Message. If the payload is a String or a primitive type, the payload is encoded as String and the JMSType is set to the target class. The _classname property is also set. The JMS Message is a TextMessage . If the payload is a byte[] , it\u2019s passed as byte[] in a JMS BytesMessage . Otherwise, the payload is encoded using included JSON serializer (JSON-B and Jackson provided OOB, for more details see Serde ). The JMSType is set to the target class. The _classname property is also set. The JMS Message is a TextMessage . For example, the following code serialize the produced Person using JSON-B. 1 2 3 4 5 6 @Incoming ( \"...\" ) @Outgoing ( \"my-channel\" ) public Person sendToJms (...) { // ... return new Person ( \"bob\" , 42 ); } It requires that the Person class can be serialized to JSON. The classname is passed in the JMSType property and _classname property.","title":"Serialization"},{"location":"jms/sending-jms-messages/#outbound-metadata","text":"When sending Messages , you can add an instance of OutgoingJmsMessageMetadata to influence how the message is going to written to JMS. 1 2 3 4 5 6 7 OutgoingJmsMessageMetadata metadata = OutgoingJmsMessageMetadata . builder () . withProperties ( JmsProperties . builder (). with ( \"some-property\" , \"some-value\" ). build ()) . build (); // Create a new message from the `incoming` message // Add `metadata` to the metadata from the `incoming` message. return incoming . addMetadata ( metadata ); The metadata allow adding properties but also override the destination.","title":"Outbound Metadata"},{"location":"jms/sending-jms-messages/#acknowledgement","text":"Once the JMS message is sent to the JMS server, the message is acknowledged. Sending a JMS message is a blocking operation. So, sending is done on a worker thread.","title":"Acknowledgement"},{"location":"jms/sending-jms-messages/#configuration-reference","text":"Attribute ( alias ) Description Type Mandatory Default client-id The client id String false connection-factory-name The name of the JMS connection factory ( javax.jms.ConnectionFactory ) to be used. If not set, it uses any exposed JMS connection factory String false correlation-id The JMS Message correlation id string false delivery-delay The delivery delay long false delivery-mode The delivery mode. Either persistent or non_persistent string false destination The name of the JMS destination. If not set the name of the channel is used String false destination-type The type of destination. It can be either queue or topic string false queue disable-message-id Omit the message id in the outbound JMS message boolean false disable-message-timestamp Omit the message timestamp in the outbound JMS message boolean false merge Whether the connector should allow multiple upstreams boolean false false password The password to connect to to the JMS server String false priority The JMS Message priority int false reply-to The reply to destination if any string false reply-to-destination-type The type of destination for the response. It can be either queue or topic string false queue session-mode The session mode. Accepted values are AUTO_ACKNOWLEDGE, SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE String false AUTO_ACKNOWLEDGE ttl The JMS Message time-to-live long false username The username to connect to to the JMS server String false","title":"Configuration Reference"},{"location":"mqtt/mqtt/","text":"MQTT Connector The MQTT connector adds support for MQTT to Reactive Messaging. It lets you receive messages from an MQTT server or broker as well as send MQTT messages. The MQTT connector is based on the Vert.x MQTT Client . Introduction MQTT is a machine-to-machine (M2M)/\"Internet of Things\" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. The MQTT Connector allows consuming messages from MQTT as well as sending MQTT messages. Using the MQTT connector To you the MQTT Connector, add the following dependency to your project: 1 2 3 4 5 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-mqtt </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> The connector name is: smallrye-mqtt . So, to indicate that a channel is managed by this connector you need: 1 2 3 4 5 # Inbound mp.messaging.incoming.[channel-name].connector = smallrye-mqtt # Outbound mp.messaging.outgoing.[channel-name].connector = smallrye-mqtt","title":"MQTT Connector"},{"location":"mqtt/mqtt/#mqtt-connector","text":"The MQTT connector adds support for MQTT to Reactive Messaging. It lets you receive messages from an MQTT server or broker as well as send MQTT messages. The MQTT connector is based on the Vert.x MQTT Client .","title":"MQTT Connector"},{"location":"mqtt/mqtt/#introduction","text":"MQTT is a machine-to-machine (M2M)/\"Internet of Things\" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. The MQTT Connector allows consuming messages from MQTT as well as sending MQTT messages.","title":"Introduction"},{"location":"mqtt/mqtt/#using-the-mqtt-connector","text":"To you the MQTT Connector, add the following dependency to your project: 1 2 3 4 5 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-mqtt </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> The connector name is: smallrye-mqtt . So, to indicate that a channel is managed by this connector you need: 1 2 3 4 5 # Inbound mp.messaging.incoming.[channel-name].connector = smallrye-mqtt # Outbound mp.messaging.outgoing.[channel-name].connector = smallrye-mqtt","title":"Using the MQTT connector"},{"location":"mqtt/receiving-mqtt-messages/","text":"Receiving messages from MQTT The MQTT Connector connects to a MQTT broker or router, and forward the messages to the Reactive Messaging application. It maps each of them into Reactive Messaging Messages . Example Let\u2019s imagine you have a MQTT server/broker running, and accessible using the mqtt:1883 address (by default it would use localhost:1883 ). Configure your application to receive MQTT messages on the prices channel as follows: 1 2 3 mp.messaging.incoming.prices.connector = smallrye-mqtt # <1> mp.messaging.incoming.prices.host = mqtt # <2> mp.messaging.incoming.prices.port = 1883 # <3> 1. Sets the connector for the prices channel 2. Configure the broker/server host name. 3. Configure the broker/server port. 1883 is the default. Note You don\u2019t need to set the MQTT topic. By default, it uses the channel name ( prices ). You can configure the topic attribute to override it. Note It is generally recommended to set the client-id . By default, the connector is generating a unique client-id . Important Message coming from MQTT have a byte[] payload. Then, your application receives Message<byte[]> . You can consume the payload directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package mqtt.inbound ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; @ApplicationScoped public class MqttPriceConsumer { @Incoming ( \"prices\" ) public void consume ( byte [] raw ) { double price = Double . parseDouble ( new String ( raw )); // process your price. } } Or, you can retrieve the Message<byte[]> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package mqtt.inbound ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; @ApplicationScoped public class MqttPriceMessageConsumer { @Incoming ( \"prices\" ) public CompletionStage < Void > consume ( Message < byte []> price ) { // process your price. // Acknowledge the incoming message return price . ack (); } } The inbound topic can use the MQTT wildcards ( + and # ). Deserialization The MQTT Connector does not handle the deserialization and creates a Message<byte[]> . Inbound Metadata The MQTT connector does not provide inbound metadata. Failure Management If a message produced from a MQTT message is nacked , a failure strategy is applied. The MQTT connector supports 3 strategies: fail - fail the application, no more MQTT messages will be processed. (default) The offset of the record that has not been processed correctly is not committed. ignore - the failure is logged, but the processing continue. Configuration Reference Attribute ( alias ) Description Type Mandatory Default auto-clean-session Set to start with a clean session ( true by default) boolean false true auto-generated-client-id Set if the MQTT client must generate clientId automatically boolean false true auto-keep-alive Set if the MQTT client must handle PINGREQ automatically boolean false true broadcast Whether or not the messages should be dispatched to multiple consumers boolean false false client-id Set the client identifier string false connect-timeout-seconds Set the connect timeout (in seconds) int false 60 failure-strategy Specify the failure strategy to apply when a message produced from a MQTT message is nacked. Values can be fail (default), or ignore string false fail host Set the MQTT server host name/IP string true keep-alive-seconds Set the keep alive timeout in seconds int false 30 max-inflight-queue Set max count of unacknowledged messages int false 10 max-message-size Set max MQTT message size in bytes int false 8092 password Set the password to connect to the server string false port Set the MQTT server port. Default to 8883 if ssl is enabled, or 1883 without ssl int false qos Set the QoS level when subscribing to the topic or when sending a message int false 0 reconnect-interval-seconds Set the reconnect interval in seconds int false 1 server-name Set the SNI server name string false ssl Set whether SSL/TLS is enabled boolean false false ssl.keystore.location Set the keystore location. In case of pem type this is the cert path string false ssl.keystore.password Set the keystore password. In case of pem type this is the key path string false ssl.keystore.type Set the keystore type [ pkcs12 , jks , pem ] string false pkcs12 ssl.truststore.location Set the truststore location. In case of pem type this is the cert path string false ssl.truststore.password Set the truststore password. In case of pem type this is not necessary string false ssl.truststore.type Set the truststore type string false pkcs12 topic Set the MQTT topic. If not set, the channel name is used string false trust-all Set whether all server certificates should be trusted boolean false false username Set the username to connect to the server string false will-flag Set if will information are provided on connection boolean false false will-qos Set the QoS level for the will message int false 0 will-retain Set if the will message must be retained boolean false false The MQTT connector is based on the Vert.x MQTT client . So you can pass any attribute supported by this client. Important A single instance of MqttClient and a single connection is used for each host / port / server-name / client-id . This client is reused for both the inbound and outbound connectors.","title":"Receiving MQTT messages"},{"location":"mqtt/receiving-mqtt-messages/#receiving-messages-from-mqtt","text":"The MQTT Connector connects to a MQTT broker or router, and forward the messages to the Reactive Messaging application. It maps each of them into Reactive Messaging Messages .","title":"Receiving messages from MQTT"},{"location":"mqtt/receiving-mqtt-messages/#example","text":"Let\u2019s imagine you have a MQTT server/broker running, and accessible using the mqtt:1883 address (by default it would use localhost:1883 ). Configure your application to receive MQTT messages on the prices channel as follows: 1 2 3 mp.messaging.incoming.prices.connector = smallrye-mqtt # <1> mp.messaging.incoming.prices.host = mqtt # <2> mp.messaging.incoming.prices.port = 1883 # <3> 1. Sets the connector for the prices channel 2. Configure the broker/server host name. 3. Configure the broker/server port. 1883 is the default. Note You don\u2019t need to set the MQTT topic. By default, it uses the channel name ( prices ). You can configure the topic attribute to override it. Note It is generally recommended to set the client-id . By default, the connector is generating a unique client-id . Important Message coming from MQTT have a byte[] payload. Then, your application receives Message<byte[]> . You can consume the payload directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package mqtt.inbound ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; @ApplicationScoped public class MqttPriceConsumer { @Incoming ( \"prices\" ) public void consume ( byte [] raw ) { double price = Double . parseDouble ( new String ( raw )); // process your price. } } Or, you can retrieve the Message<byte[]> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package mqtt.inbound ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; @ApplicationScoped public class MqttPriceMessageConsumer { @Incoming ( \"prices\" ) public CompletionStage < Void > consume ( Message < byte []> price ) { // process your price. // Acknowledge the incoming message return price . ack (); } } The inbound topic can use the MQTT wildcards ( + and # ).","title":"Example"},{"location":"mqtt/receiving-mqtt-messages/#deserialization","text":"The MQTT Connector does not handle the deserialization and creates a Message<byte[]> .","title":"Deserialization"},{"location":"mqtt/receiving-mqtt-messages/#inbound-metadata","text":"The MQTT connector does not provide inbound metadata.","title":"Inbound Metadata"},{"location":"mqtt/receiving-mqtt-messages/#failure-management","text":"If a message produced from a MQTT message is nacked , a failure strategy is applied. The MQTT connector supports 3 strategies: fail - fail the application, no more MQTT messages will be processed. (default) The offset of the record that has not been processed correctly is not committed. ignore - the failure is logged, but the processing continue.","title":"Failure Management"},{"location":"mqtt/receiving-mqtt-messages/#configuration-reference","text":"Attribute ( alias ) Description Type Mandatory Default auto-clean-session Set to start with a clean session ( true by default) boolean false true auto-generated-client-id Set if the MQTT client must generate clientId automatically boolean false true auto-keep-alive Set if the MQTT client must handle PINGREQ automatically boolean false true broadcast Whether or not the messages should be dispatched to multiple consumers boolean false false client-id Set the client identifier string false connect-timeout-seconds Set the connect timeout (in seconds) int false 60 failure-strategy Specify the failure strategy to apply when a message produced from a MQTT message is nacked. Values can be fail (default), or ignore string false fail host Set the MQTT server host name/IP string true keep-alive-seconds Set the keep alive timeout in seconds int false 30 max-inflight-queue Set max count of unacknowledged messages int false 10 max-message-size Set max MQTT message size in bytes int false 8092 password Set the password to connect to the server string false port Set the MQTT server port. Default to 8883 if ssl is enabled, or 1883 without ssl int false qos Set the QoS level when subscribing to the topic or when sending a message int false 0 reconnect-interval-seconds Set the reconnect interval in seconds int false 1 server-name Set the SNI server name string false ssl Set whether SSL/TLS is enabled boolean false false ssl.keystore.location Set the keystore location. In case of pem type this is the cert path string false ssl.keystore.password Set the keystore password. In case of pem type this is the key path string false ssl.keystore.type Set the keystore type [ pkcs12 , jks , pem ] string false pkcs12 ssl.truststore.location Set the truststore location. In case of pem type this is the cert path string false ssl.truststore.password Set the truststore password. In case of pem type this is not necessary string false ssl.truststore.type Set the truststore type string false pkcs12 topic Set the MQTT topic. If not set, the channel name is used string false trust-all Set whether all server certificates should be trusted boolean false false username Set the username to connect to the server string false will-flag Set if will information are provided on connection boolean false false will-qos Set the QoS level for the will message int false 0 will-retain Set if the will message must be retained boolean false false The MQTT connector is based on the Vert.x MQTT client . So you can pass any attribute supported by this client. Important A single instance of MqttClient and a single connection is used for each host / port / server-name / client-id . This client is reused for both the inbound and outbound connectors.","title":"Configuration Reference"},{"location":"mqtt/sending-messages-to-mqtt/","text":"Sending messages to MQTT The MQTT Connector can write Reactive Messaging Messages as MQTT Message. Example Let\u2019s imagine you have a MQTT server/broker running, and accessible using the mqtt:1883 address (by default it would use localhost:1883 ). Configure your application to write the messages from the prices channel into a MQTT Messages as follows: 1 2 3 mp.messaging.outgoing.prices.type = smallrye-mqtt mp.messaging.outgoing.prices.host = mqtt mp.messaging.outgoing.prices.port = 1883 Sets the connector for the prices channel Configure the broker/server host name. Configure the broker/server port. 1883 is the default. Note You don\u2019t need to set the MQTT topic. By default, it uses the channel name ( prices ). You can configure the topic attribute to override it. NOTE: It is generally recommended to set the client-id . By default, the connector is generating a unique client-id . Then, your application must send Message<Double> to the prices channel. It can use double payloads as in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package mqtt.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class MqttPriceProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Double > generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()); } } Or, you can send Message<Double> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package mqtt.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class MqttPriceMessageProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Message < Double >> generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> Message . of ( random . nextDouble ())); } } Serialization The Message sent to MQTT can have various payload types: JsonObject : JSON string encoded as byte[] JsonArray : JSON string encoded as byte[] java.lang.String and Java primitive types: toString encoded as byte[] byte[] complex objects: The objects are encoded to JSON and passed as byte[] Outbound Metadata The MQTT connector does not provide outbound metadata. Acknowledgement MQTT acknowledgement depends on the QoS level. The message is acknowledged when the broker indicated the successful reception of the message (or immediately if the level of QoS does not support acknowledgment). If a MQTT message cannot be sent to the broker, the message is nacked . Configuration Reference Attribute ( alias ) Description Type Mandatory Default auto-clean-session Set to start with a clean session ( true by default) boolean false true auto-generated-client-id Set if the MQTT client must generate clientId automatically boolean false true auto-keep-alive Set if the MQTT client must handle PINGREQ automatically boolean false true client-id Set the client identifier string false connect-timeout-seconds Set the connect timeout (in seconds) int false 60 host Set the MQTT server host name/IP string true keep-alive-seconds Set the keep alive timeout in seconds int false 30 max-inflight-queue Set max count of unacknowledged messages int false 10 max-message-size Set max MQTT message size in bytes int false 8092 merge Whether the connector should allow multiple upstreams boolean false false password Set the password to connect to the server string false port Set the MQTT server port. Default to 8883 if ssl is enabled, or 1883 without ssl int false qos Set the QoS level when subscribing to the topic or when sending a message int false 0 reconnect-interval-seconds Set the reconnect interval in seconds int false 1 server-name Set the SNI server name string false ssl Set whether SSL/TLS is enabled boolean false false ssl.keystore.location Set the keystore location. In case of pem type this is the cert path string false ssl.keystore.password Set the keystore password. In case of pem type this is the key path string false ssl.keystore.type Set the keystore type [ pkcs12 , jks , pem ] string false pkcs12 ssl.truststore.location Set the truststore location. In case of pem type this is the cert path string false ssl.truststore.password Set the truststore password. In case of pem type this is not necessary string false ssl.truststore.type Set the truststore type string false pkcs12 topic Set the MQTT topic. If not set, the channel name is used string false trust-all Set whether all server certificates should be trusted boolean false false username Set the username to connect to the server string false will-flag Set if will information are provided on connection boolean false false will-qos Set the QoS level for the will message int false 0 will-retain Set if the will message must be retained boolean false false The MQTT connector is based on the Vert.x MQTT client . So you can pass any attribute supported by this client. Important A single instance of MqttClient and a single connection is used for each host / port / server-name / client-id . This client is reused for both the inbound and outbound connectors.","title":"Sending MQTT messages"},{"location":"mqtt/sending-messages-to-mqtt/#sending-messages-to-mqtt","text":"The MQTT Connector can write Reactive Messaging Messages as MQTT Message.","title":"Sending messages to MQTT"},{"location":"mqtt/sending-messages-to-mqtt/#example","text":"Let\u2019s imagine you have a MQTT server/broker running, and accessible using the mqtt:1883 address (by default it would use localhost:1883 ). Configure your application to write the messages from the prices channel into a MQTT Messages as follows: 1 2 3 mp.messaging.outgoing.prices.type = smallrye-mqtt mp.messaging.outgoing.prices.host = mqtt mp.messaging.outgoing.prices.port = 1883 Sets the connector for the prices channel Configure the broker/server host name. Configure the broker/server port. 1883 is the default. Note You don\u2019t need to set the MQTT topic. By default, it uses the channel name ( prices ). You can configure the topic attribute to override it. NOTE: It is generally recommended to set the client-id . By default, the connector is generating a unique client-id . Then, your application must send Message<Double> to the prices channel. It can use double payloads as in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package mqtt.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class MqttPriceProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Double > generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()); } } Or, you can send Message<Double> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package mqtt.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class MqttPriceMessageProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Message < Double >> generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> Message . of ( random . nextDouble ())); } }","title":"Example"},{"location":"mqtt/sending-messages-to-mqtt/#serialization","text":"The Message sent to MQTT can have various payload types: JsonObject : JSON string encoded as byte[] JsonArray : JSON string encoded as byte[] java.lang.String and Java primitive types: toString encoded as byte[] byte[] complex objects: The objects are encoded to JSON and passed as byte[]","title":"Serialization"},{"location":"mqtt/sending-messages-to-mqtt/#outbound-metadata","text":"The MQTT connector does not provide outbound metadata.","title":"Outbound Metadata"},{"location":"mqtt/sending-messages-to-mqtt/#acknowledgement","text":"MQTT acknowledgement depends on the QoS level. The message is acknowledged when the broker indicated the successful reception of the message (or immediately if the level of QoS does not support acknowledgment). If a MQTT message cannot be sent to the broker, the message is nacked .","title":"Acknowledgement"},{"location":"mqtt/sending-messages-to-mqtt/#configuration-reference","text":"Attribute ( alias ) Description Type Mandatory Default auto-clean-session Set to start with a clean session ( true by default) boolean false true auto-generated-client-id Set if the MQTT client must generate clientId automatically boolean false true auto-keep-alive Set if the MQTT client must handle PINGREQ automatically boolean false true client-id Set the client identifier string false connect-timeout-seconds Set the connect timeout (in seconds) int false 60 host Set the MQTT server host name/IP string true keep-alive-seconds Set the keep alive timeout in seconds int false 30 max-inflight-queue Set max count of unacknowledged messages int false 10 max-message-size Set max MQTT message size in bytes int false 8092 merge Whether the connector should allow multiple upstreams boolean false false password Set the password to connect to the server string false port Set the MQTT server port. Default to 8883 if ssl is enabled, or 1883 without ssl int false qos Set the QoS level when subscribing to the topic or when sending a message int false 0 reconnect-interval-seconds Set the reconnect interval in seconds int false 1 server-name Set the SNI server name string false ssl Set whether SSL/TLS is enabled boolean false false ssl.keystore.location Set the keystore location. In case of pem type this is the cert path string false ssl.keystore.password Set the keystore password. In case of pem type this is the key path string false ssl.keystore.type Set the keystore type [ pkcs12 , jks , pem ] string false pkcs12 ssl.truststore.location Set the truststore location. In case of pem type this is the cert path string false ssl.truststore.password Set the truststore password. In case of pem type this is not necessary string false ssl.truststore.type Set the truststore type string false pkcs12 topic Set the MQTT topic. If not set, the channel name is used string false trust-all Set whether all server certificates should be trusted boolean false false username Set the username to connect to the server string false will-flag Set if will information are provided on connection boolean false false will-qos Set the QoS level for the will message int false 0 will-retain Set if the will message must be retained boolean false false The MQTT connector is based on the Vert.x MQTT client . So you can pass any attribute supported by this client. Important A single instance of MqttClient and a single connection is used for each host / port / server-name / client-id . This client is reused for both the inbound and outbound connectors.","title":"Configuration Reference"},{"location":"rabbitmq/rabbitmq-client-customization/","text":"Customizing the underlying RabbitMQ client You can customize the underlying RabbitMQ Client configuration by producing an instance of RabbitMQOptions : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Produces @Identifier ( \"my-named-options\" ) public RabbitMQOptions getNamedOptions () { // You can use the produced options to configure the TLS connection PemKeyCertOptions keycert = new PemKeyCertOptions () . addCertPath ( \"./tls/tls.crt\" ) . addKeyPath ( \"./tls/tls.key\" ); PemTrustOptions trust = new PemTrustOptions (). addCertPath ( \"./tlc/ca.crt\" ); return ( RabbitMQOptions ) new RabbitMQOptions () . setUser ( \"admin\" ) . setPassword ( \"test\" ) . setSsl ( true ) . setPemKeyCertOptions ( keycert ) . setPemTrustOptions ( trust ) . setHostnameVerificationAlgorithm ( \"\" ) . setConnectTimeout ( 30000 ) . setReconnectInterval ( 5000 ); } This instance is retrieved and used to configure the client used by the connector. You need to indicate the name of the client using the client-options-name attribute: 1 mp.messaging.incoming.prices.client-options-name=my-named-options","title":"Client Customization"},{"location":"rabbitmq/rabbitmq-client-customization/#customizing-the-underlying-rabbitmq-client","text":"You can customize the underlying RabbitMQ Client configuration by producing an instance of RabbitMQOptions : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Produces @Identifier ( \"my-named-options\" ) public RabbitMQOptions getNamedOptions () { // You can use the produced options to configure the TLS connection PemKeyCertOptions keycert = new PemKeyCertOptions () . addCertPath ( \"./tls/tls.crt\" ) . addKeyPath ( \"./tls/tls.key\" ); PemTrustOptions trust = new PemTrustOptions (). addCertPath ( \"./tlc/ca.crt\" ); return ( RabbitMQOptions ) new RabbitMQOptions () . setUser ( \"admin\" ) . setPassword ( \"test\" ) . setSsl ( true ) . setPemKeyCertOptions ( keycert ) . setPemTrustOptions ( trust ) . setHostnameVerificationAlgorithm ( \"\" ) . setConnectTimeout ( 30000 ) . setReconnectInterval ( 5000 ); } This instance is retrieved and used to configure the client used by the connector. You need to indicate the name of the client using the client-options-name attribute: 1 mp.messaging.incoming.prices.client-options-name=my-named-options","title":"Customizing the underlying RabbitMQ client"},{"location":"rabbitmq/rabbitmq-cloud/","text":"Connecting to managed instances This section describes the connector configuration to use managed RabbitMQ instances (hosted on the Cloud). Cloud AMQP To connect to an instance of RabbitMQ hosted on Cloud AMQP , use the following configuration: 1 2 3 4 5 6 rabbitmq-host = host-name rabbitmq-port = 5671 rabbitmq-username = user-name rabbitmq-password = password rabbitmq-virtual-host = user-name rabbitmq-ssl = true You can extract the values from the AMQPS url displayed on the administration portal: 1 amqps://user-name:password@host/user-name Amazon MQ Amazon MQ can host RabbitMQ brokers (as well as AMQP 1.0 brokers). To connect to a RabbitMQ instance hosted on Amazon MQ, use the following configuration: 1 2 3 4 5 rabbitmq-host = host-name rabbitmq-port = 5671 rabbitmq-username = user-name rabbitmq-password = password rabbitmq-ssl = true You can extract the host value from the AMQPS url displayed on the administration console: 1 amqps://foobarbaz.mq.us-east-2.amazonaws.com:5671 The username and password are configured during the broker creation.","title":"Connecting to managed instances"},{"location":"rabbitmq/rabbitmq-cloud/#connecting-to-managed-instances","text":"This section describes the connector configuration to use managed RabbitMQ instances (hosted on the Cloud).","title":"Connecting to managed instances"},{"location":"rabbitmq/rabbitmq-cloud/#cloud-amqp","text":"To connect to an instance of RabbitMQ hosted on Cloud AMQP , use the following configuration: 1 2 3 4 5 6 rabbitmq-host = host-name rabbitmq-port = 5671 rabbitmq-username = user-name rabbitmq-password = password rabbitmq-virtual-host = user-name rabbitmq-ssl = true You can extract the values from the AMQPS url displayed on the administration portal: 1 amqps://user-name:password@host/user-name","title":"Cloud AMQP"},{"location":"rabbitmq/rabbitmq-cloud/#amazon-mq","text":"Amazon MQ can host RabbitMQ brokers (as well as AMQP 1.0 brokers). To connect to a RabbitMQ instance hosted on Amazon MQ, use the following configuration: 1 2 3 4 5 rabbitmq-host = host-name rabbitmq-port = 5671 rabbitmq-username = user-name rabbitmq-password = password rabbitmq-ssl = true You can extract the host value from the AMQPS url displayed on the administration console: 1 amqps://foobarbaz.mq.us-east-2.amazonaws.com:5671 The username and password are configured during the broker creation.","title":"Amazon MQ"},{"location":"rabbitmq/rabbitmq-health/","text":"Health reporting The RabbitMQ connector reports the readiness and liveness of each channel managed by the connector. On the inbound side (receiving messages from RabbitMQ), the check verifies that the receiver is connected to the broker. On the outbound side (sending records to RabbitMQ), the check verifies that the sender is not disconnected from the broker; the sender may still be in an initialized state (connection not yet attempted), but this is regarded as live/ready.","title":"Health Check"},{"location":"rabbitmq/rabbitmq-health/#health-reporting","text":"The RabbitMQ connector reports the readiness and liveness of each channel managed by the connector. On the inbound side (receiving messages from RabbitMQ), the check verifies that the receiver is connected to the broker. On the outbound side (sending records to RabbitMQ), the check verifies that the sender is not disconnected from the broker; the sender may still be in an initialized state (connection not yet attempted), but this is regarded as live/ready.","title":"Health reporting"},{"location":"rabbitmq/rabbitmq/","text":"RabbitMQ Connector The RabbitMQ Connector adds support for RabbitMQ to Reactive Messaging, based on the AMQP 0-9-1 Protocol Specification. Advanced Message Queuing Protocol 0-9-1 ( AMQP 0-9-1 ) is an open standard for passing business messages between applications or organizations. With this connector, your application can: receive messages from a RabbitMQ queue send messages to a RabbitMQ exchange The RabbitMQ connector is based on the Vert.x RabbitMQ Client . Important The AMQP connector supports the AMQP 1.0 protocol, which is very different from AMQP 0-9-1. You can use the AMQP connector with RabbitMQ provided that the latter has the AMQP 1.0 Plugin installed, albeit with reduced functionality. Using the RabbitMQ connector To use the RabbitMQ Connector, add the following dependency to your project: 1 2 3 4 5 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-rabbitmq </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> The connector name is: smallrye-rabbitmq . So, to indicate that a channel is managed by this connector you need: 1 2 3 4 5 # Inbound mp.messaging.incoming.[channel-name].connector = smallrye-rabbitmq # Outbound mp.messaging.outgoing.[channel-name].connector = smallrye-rabbitmq","title":"RabbitMQ Connector"},{"location":"rabbitmq/rabbitmq/#rabbitmq-connector","text":"The RabbitMQ Connector adds support for RabbitMQ to Reactive Messaging, based on the AMQP 0-9-1 Protocol Specification. Advanced Message Queuing Protocol 0-9-1 ( AMQP 0-9-1 ) is an open standard for passing business messages between applications or organizations. With this connector, your application can: receive messages from a RabbitMQ queue send messages to a RabbitMQ exchange The RabbitMQ connector is based on the Vert.x RabbitMQ Client . Important The AMQP connector supports the AMQP 1.0 protocol, which is very different from AMQP 0-9-1. You can use the AMQP connector with RabbitMQ provided that the latter has the AMQP 1.0 Plugin installed, albeit with reduced functionality.","title":"RabbitMQ Connector"},{"location":"rabbitmq/rabbitmq/#using-the-rabbitmq-connector","text":"To use the RabbitMQ Connector, add the following dependency to your project: 1 2 3 4 5 <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-reactive-messaging-rabbitmq </artifactId> <version> 3.14.0-SNAPSHOT </version> </dependency> The connector name is: smallrye-rabbitmq . So, to indicate that a channel is managed by this connector you need: 1 2 3 4 5 # Inbound mp.messaging.incoming.[channel-name].connector = smallrye-rabbitmq # Outbound mp.messaging.outgoing.[channel-name].connector = smallrye-rabbitmq","title":"Using the RabbitMQ connector"},{"location":"rabbitmq/receiving-messages-from-rabbitmq/","text":"Receiving messages from RabbitMQ The RabbitMQ connector lets you retrieve messages from a RabbitMQ broker . The RabbitMQ connector retrieves RabbitMQ Messages and maps each of them into Reactive Messaging Messages . Note In this context, the reactive messaging concept of a Channel is realised as a RabbitMQ Queue . Example Let\u2019s imagine you have a RabbitMQ broker running, and accessible using the rabbitmq:5672 address (by default it would use localhost:5672 ). Configure your application to receive RabbitMQ Messages on the prices channel as follows: 1 2 3 4 5 6 7 8 rabbitmq-host = rabbitmq # <1> rabbitmq-port = 5672 # <2> rabbitmq-username = my-username # <3> rabbitmq-password = my-password # <4> mp.messaging.incoming.prices.connector = smallrye-rabbitmq # <5> mp.messaging.incoming.prices.queue.name = my-queue # <6> mp.messaging.incoming.prices.routing-keys = urgent # <7> Configures the broker/router host name. You can do it per channel (using the host attribute) or globally using rabbitmq-host . Configures the broker/router port. You can do it per channel (using the port attribute) or globally using rabbitmq-port . The default is 5672. Configures the broker/router username if required. You can do it per channel (using the username attribute) or globally using rabbitmq-username . Configures the broker/router password if required. You can do it per channel (using the password attribute) or globally using rabbitmq-password . Instructs the prices channel to be managed by the RabbitMQ connector. Configures the RabbitMQ queue to read messages from. Configures the binding between the RabbitMQ exchange and the RabbitMQ queue using a routing key. The default is # (all messages will be forwarded from the exchange to the queue) but in general this can be a comma-separated list of one or more keys. Then, your application receives Message<String> . You can consume the payload directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package rabbitmq.inbound ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; @ApplicationScoped public class RabbitMQPriceConsumer { @Incoming ( \"prices\" ) public void consume ( String price ) { // process your price. } } Or, you can retrieve the Message<String> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package rabbitmq.inbound ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; @ApplicationScoped public class RabbitMQPriceMessageConsumer { @Incoming ( \"prices\" ) public CompletionStage < Void > consume ( Message < String > price ) { // process your price. // Acknowledge the incoming message, marking the RabbitMQ message as `accepted`. return price . ack (); } } Note Whether you need to explicitly acknowledge the message depends on the auto-acknowledgement channel setting; if that is set to true then your message will be automatically acknowledged on receipt. Deserialization The connector converts incoming RabbitMQ Messages into Reactive Messaging Message<T> instances. The payload type T depends on the value of the RabbitMQ received message Envelope content_type and content_encoding properties. content_encoding content_type Type Value present n/a byte[] No value text/plain String No value application/json a JSON element which can be a JsonArray , JsonObject , String , \u2026\u200betc if the buffer contains an array, object, string,... No value Anything else byte[] If you send objects with this RabbitMQ connector (outbound connector), they are encoded as JSON and sent with content_type set to application/json . You can receive this payload using (Vert.x) JSON Objects, and then map it to the object class you want: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @ApplicationScoped public static class Generator { @Outgoing ( \"to-rabbitmq\" ) public Multi < Price > prices () { // <1> AtomicInteger count = new AtomicInteger (); return Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 1000 )) . map ( l -> new Price (). setPrice ( count . incrementAndGet ())) . onOverflow (). drop (); } } @ApplicationScoped public static class Consumer { List < Price > prices = new CopyOnWriteArrayList <> (); @Incoming ( \"from-rabbitmq\" ) public void consume ( JsonObject p ) { // <2> Price price = p . mapTo ( Price . class ); // <3> prices . add ( price ); } public List < Price > list () { return prices ; } } The Price instances are automatically encoded to JSON by the connector You can receive it using a JsonObject Then, you can reconstruct the instance using the mapTo method Inbound Metadata Messages coming from RabbitMQ contain an instance of IncomingRabbitMQMetadata in the metadata. RabbitMQ message headers can be accessed from the metadata either by calling getHeader(String header, Class<T> type) to retrieve a single header value. or getHeaders() to get a map of all header values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 final Optional < IncomingRabbitMQMetadata > metadata = incomingMessage . getMetadata ( IncomingRabbitMQMetadata . class ); metadata . ifPresent ( meta -> { final Optional < String > contentEncoding = meta . getContentEncoding (); final Optional < String > contentType = meta . getContentType (); final Optional < String > correlationId = meta . getCorrelationId (); final Optional < ZonedDateTime > creationTime = meta . getCreationTime ( ZoneId . systemDefault ()); final Optional < Integer > priority = meta . getPriority (); final Optional < String > replyTo = meta . getReplyTo (); final Optional < String > userId = meta . getUserId (); // Access a single String-valued header final Optional < String > stringHeader = meta . getHeader ( \"my-header\" , String . class ); // Access all headers final Map < String , Object > headers = meta . getHeaders (); // ... }); The type <T> of the header value depends on the RabbitMQ type used for the header: RabbitMQ Header Type T String String Boolean Boolean Number Number List java.util.List Acknowledgement When a Reactive Messaging Message associated with a RabbitMQ Message is acknowledged, it informs the broker that the message has been accepted . Whether you need to explicitly acknowledge the message depends on the auto-acknowledgement setting for the channel; if that is set to true then your message will be automatically acknowledged on receipt. Failure Management If a message produced from a RabbitMQ message is nacked , a failure strategy is applied. The RabbitMQ connector supports three strategies, controlled by the failure-strategy channel setting: fail - fail the application; no more RabbitMQ messages will be processed. The RabbitMQ message is marked as rejected. accept - this strategy marks the RabbitMQ message as accepted. The processing continues ignoring the failure. reject - this strategy marks the RabbitMQ message as rejected (default). The processing continues with the next message. Configuration Reference Attribute ( alias ) Description Type Mandatory Default auto-acknowledgement Whether the received RabbitMQ messages must be acknowledged when received; if true then delivery constitutes acknowledgement boolean false false auto-bind-dlq Whether to automatically declare the DLQ and bind it to the binder DLX boolean false false automatic-recovery-enabled Whether automatic connection recovery is enabled boolean false false automatic-recovery-on-initial-connection Whether automatic recovery on initial connections is enabled boolean false true broadcast Whether the received RabbitMQ messages must be dispatched to multiple subscribers boolean false false client-options-name (rabbitmq-client-options-name) The name of the RabbitMQ Client Option bean used to customize the RabbitMQ client configuration string false connection-timeout The TCP connection timeout (ms); 0 is interpreted as no timeout int false 60000 credentials-provider-name (rabbitmq-credentials-provider-name) The name of the RabbitMQ Credentials Provider bean used to provide dynamic credentials to the RabbitMQ client string false dead-letter-exchange A DLX to assign to the queue. Relevant only if auto-bind-dlq is true string false DLX dead-letter-exchange-type The type of the DLX to assign to the queue. Relevant only if auto-bind-dlq is true string false direct dead-letter-queue-name The name of the DLQ; if not supplied will default to the queue name with '.dlq' appended string false dead-letter-routing-key A dead letter routing key to assign to the queue; if not supplied will default to the queue name string false dlx.declare Whether to declare the dead letter exchange binding. Relevant only if auto-bind-dlq is true; set to false if these are expected to be set up independently boolean false false exchange.auto-delete Whether the exchange should be deleted after use boolean false false exchange.declare Whether to declare the exchange; set to false if the exchange is expected to be set up independently boolean false true exchange.durable Whether the exchange is durable boolean false true exchange.name The exchange that messages are published to or consumed from. If not set, the channel name is used string false exchange.type The exchange type: direct, fanout, headers or topic (default) string false topic failure-strategy The failure strategy to apply when a RabbitMQ message is nacked. Accepted values are fail , accept , reject (default) string false reject handshake-timeout The AMQP 0-9-1 protocol handshake timeout (ms) int false 10000 host (rabbitmq-host) The broker hostname string false localhost include-properties Whether to include properties when a broker message is passed on the event bus boolean false false keep-most-recent Whether to discard old messages instead of recent ones boolean false false max-incoming-internal-queue-size The maximum size of the incoming internal queue int false network-recovery-interval How long (ms) will automatic recovery wait before attempting to reconnect int false 5000 password (rabbitmq-password) The password used to authenticate to the broker string false port (rabbitmq-port) The broker port int false 5672 queue.auto-delete Whether the queue should be deleted after use boolean false false queue.declare Whether to declare the queue and binding; set to false if these are expected to be set up independently boolean false true queue.durable Whether the queue is durable boolean false true queue.exclusive Whether the queue is for exclusive use boolean false false queue.name The queue from which messages are consumed. string true queue.ttl If specified, the time (ms) for which a message can remain in the queue undelivered before it is dead long false reconnect-attempts (rabbitmq-reconnect-attempts) The number of reconnection attempts int false 100 reconnect-interval (rabbitmq-reconnect-interval) The interval (in seconds) between two reconnection attempts int false 10 requested-channel-max The initially requested maximum channel number int false 2047 requested-heartbeat The initially requested heartbeat interval (seconds), zero for none int false 60 routing-keys A comma-separated list of routing keys to bind the queue to the exchange string false # ssl (rabbitmq-ssl) Whether or not the connection should use SSL boolean false false tracing.attribute-headers A comma-separated list of headers that should be recorded as span attributes. Relevant only if tracing.enabled=true string false `` tracing.enabled Whether tracing is enabled (default) or disabled boolean false true trust-all (rabbitmq-trust-all) Whether to skip trust certificate verification boolean false false trust-store-password (rabbitmq-trust-store-password) The password of the JKS trust store string false trust-store-path (rabbitmq-trust-store-path) The path to a JKS trust store string false use-nio Whether usage of NIO Sockets is enabled boolean false false user The user name to use when connecting to the broker string false guest username (rabbitmq-username) The username used to authenticate to the broker string false virtual-host (rabbitmq-virtual-host) The virtual host to use when connecting to the broker string false / To use an existing queue , you need to configure the queue.name attribute. For example, if you have a RabbitMQ broker already configured with a queue called peopleQueue that you wish to read messages from, you need the following configuration: 1 2 mp.messaging.incoming.people.connector = smallrye-rabbitmq mp.messaging.incoming.people.queue.name = peopleQueue If you want RabbitMQ to create the queue for you but bind it to an existing topic exchange people , you need the following configuration: 1 2 3 mp.messaging.incoming.people.connector = smallrye-rabbitmq mp.messaging.incoming.people.queue.name = peopleQueue mp.messaging.incoming.people.queue.declare = true Note In the above the channel name people is implicitly assumed to be the name of the exchange; if this is not the case you would need to name the exchange explicitly using the exchange.name property. If you want RabbitMQ to create the people exchange, queue and binding, you need the following configuration: 1 2 3 4 5 mp.messaging.incoming.people.connector = smallrye-rabbitmq mp.messaging.incoming.people.exchange.declare = true mp.messaging.incoming.people.queue.name = peopleQueue mp.messaging.incoming.people.queue.declare = true mp.messaging.incoming.people.queue.routing-keys = tall,short In the above we have used an explicit list of routing keys rather than the default ( # ). Each component of the list creates a separate binding between the queue and the exchange, so in the case above we would have two bindings; one based on a routing key of tall , the other based on one of short . Note The default value of routing-keys is # (indicating a match against all possible routing keys) which is only appropriate for topic Exchanges. If you are using other types of exchange and/or need to declare queue bindings, you\u2019ll need to supply a valid value for the exchange in question.","title":"Receiving messages"},{"location":"rabbitmq/receiving-messages-from-rabbitmq/#receiving-messages-from-rabbitmq","text":"The RabbitMQ connector lets you retrieve messages from a RabbitMQ broker . The RabbitMQ connector retrieves RabbitMQ Messages and maps each of them into Reactive Messaging Messages . Note In this context, the reactive messaging concept of a Channel is realised as a RabbitMQ Queue .","title":"Receiving messages from RabbitMQ"},{"location":"rabbitmq/receiving-messages-from-rabbitmq/#example","text":"Let\u2019s imagine you have a RabbitMQ broker running, and accessible using the rabbitmq:5672 address (by default it would use localhost:5672 ). Configure your application to receive RabbitMQ Messages on the prices channel as follows: 1 2 3 4 5 6 7 8 rabbitmq-host = rabbitmq # <1> rabbitmq-port = 5672 # <2> rabbitmq-username = my-username # <3> rabbitmq-password = my-password # <4> mp.messaging.incoming.prices.connector = smallrye-rabbitmq # <5> mp.messaging.incoming.prices.queue.name = my-queue # <6> mp.messaging.incoming.prices.routing-keys = urgent # <7> Configures the broker/router host name. You can do it per channel (using the host attribute) or globally using rabbitmq-host . Configures the broker/router port. You can do it per channel (using the port attribute) or globally using rabbitmq-port . The default is 5672. Configures the broker/router username if required. You can do it per channel (using the username attribute) or globally using rabbitmq-username . Configures the broker/router password if required. You can do it per channel (using the password attribute) or globally using rabbitmq-password . Instructs the prices channel to be managed by the RabbitMQ connector. Configures the RabbitMQ queue to read messages from. Configures the binding between the RabbitMQ exchange and the RabbitMQ queue using a routing key. The default is # (all messages will be forwarded from the exchange to the queue) but in general this can be a comma-separated list of one or more keys. Then, your application receives Message<String> . You can consume the payload directly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package rabbitmq.inbound ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; @ApplicationScoped public class RabbitMQPriceConsumer { @Incoming ( \"prices\" ) public void consume ( String price ) { // process your price. } } Or, you can retrieve the Message<String> : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package rabbitmq.inbound ; import java.util.concurrent.CompletionStage ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Incoming ; import org.eclipse.microprofile.reactive.messaging.Message ; @ApplicationScoped public class RabbitMQPriceMessageConsumer { @Incoming ( \"prices\" ) public CompletionStage < Void > consume ( Message < String > price ) { // process your price. // Acknowledge the incoming message, marking the RabbitMQ message as `accepted`. return price . ack (); } } Note Whether you need to explicitly acknowledge the message depends on the auto-acknowledgement channel setting; if that is set to true then your message will be automatically acknowledged on receipt.","title":"Example"},{"location":"rabbitmq/receiving-messages-from-rabbitmq/#deserialization","text":"The connector converts incoming RabbitMQ Messages into Reactive Messaging Message<T> instances. The payload type T depends on the value of the RabbitMQ received message Envelope content_type and content_encoding properties. content_encoding content_type Type Value present n/a byte[] No value text/plain String No value application/json a JSON element which can be a JsonArray , JsonObject , String , \u2026\u200betc if the buffer contains an array, object, string,... No value Anything else byte[] If you send objects with this RabbitMQ connector (outbound connector), they are encoded as JSON and sent with content_type set to application/json . You can receive this payload using (Vert.x) JSON Objects, and then map it to the object class you want: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @ApplicationScoped public static class Generator { @Outgoing ( \"to-rabbitmq\" ) public Multi < Price > prices () { // <1> AtomicInteger count = new AtomicInteger (); return Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 1000 )) . map ( l -> new Price (). setPrice ( count . incrementAndGet ())) . onOverflow (). drop (); } } @ApplicationScoped public static class Consumer { List < Price > prices = new CopyOnWriteArrayList <> (); @Incoming ( \"from-rabbitmq\" ) public void consume ( JsonObject p ) { // <2> Price price = p . mapTo ( Price . class ); // <3> prices . add ( price ); } public List < Price > list () { return prices ; } } The Price instances are automatically encoded to JSON by the connector You can receive it using a JsonObject Then, you can reconstruct the instance using the mapTo method","title":"Deserialization"},{"location":"rabbitmq/receiving-messages-from-rabbitmq/#inbound-metadata","text":"Messages coming from RabbitMQ contain an instance of IncomingRabbitMQMetadata in the metadata. RabbitMQ message headers can be accessed from the metadata either by calling getHeader(String header, Class<T> type) to retrieve a single header value. or getHeaders() to get a map of all header values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 final Optional < IncomingRabbitMQMetadata > metadata = incomingMessage . getMetadata ( IncomingRabbitMQMetadata . class ); metadata . ifPresent ( meta -> { final Optional < String > contentEncoding = meta . getContentEncoding (); final Optional < String > contentType = meta . getContentType (); final Optional < String > correlationId = meta . getCorrelationId (); final Optional < ZonedDateTime > creationTime = meta . getCreationTime ( ZoneId . systemDefault ()); final Optional < Integer > priority = meta . getPriority (); final Optional < String > replyTo = meta . getReplyTo (); final Optional < String > userId = meta . getUserId (); // Access a single String-valued header final Optional < String > stringHeader = meta . getHeader ( \"my-header\" , String . class ); // Access all headers final Map < String , Object > headers = meta . getHeaders (); // ... }); The type <T> of the header value depends on the RabbitMQ type used for the header: RabbitMQ Header Type T String String Boolean Boolean Number Number List java.util.List","title":"Inbound Metadata"},{"location":"rabbitmq/receiving-messages-from-rabbitmq/#acknowledgement","text":"When a Reactive Messaging Message associated with a RabbitMQ Message is acknowledged, it informs the broker that the message has been accepted . Whether you need to explicitly acknowledge the message depends on the auto-acknowledgement setting for the channel; if that is set to true then your message will be automatically acknowledged on receipt.","title":"Acknowledgement"},{"location":"rabbitmq/receiving-messages-from-rabbitmq/#failure-management","text":"If a message produced from a RabbitMQ message is nacked , a failure strategy is applied. The RabbitMQ connector supports three strategies, controlled by the failure-strategy channel setting: fail - fail the application; no more RabbitMQ messages will be processed. The RabbitMQ message is marked as rejected. accept - this strategy marks the RabbitMQ message as accepted. The processing continues ignoring the failure. reject - this strategy marks the RabbitMQ message as rejected (default). The processing continues with the next message.","title":"Failure Management"},{"location":"rabbitmq/receiving-messages-from-rabbitmq/#configuration-reference","text":"Attribute ( alias ) Description Type Mandatory Default auto-acknowledgement Whether the received RabbitMQ messages must be acknowledged when received; if true then delivery constitutes acknowledgement boolean false false auto-bind-dlq Whether to automatically declare the DLQ and bind it to the binder DLX boolean false false automatic-recovery-enabled Whether automatic connection recovery is enabled boolean false false automatic-recovery-on-initial-connection Whether automatic recovery on initial connections is enabled boolean false true broadcast Whether the received RabbitMQ messages must be dispatched to multiple subscribers boolean false false client-options-name (rabbitmq-client-options-name) The name of the RabbitMQ Client Option bean used to customize the RabbitMQ client configuration string false connection-timeout The TCP connection timeout (ms); 0 is interpreted as no timeout int false 60000 credentials-provider-name (rabbitmq-credentials-provider-name) The name of the RabbitMQ Credentials Provider bean used to provide dynamic credentials to the RabbitMQ client string false dead-letter-exchange A DLX to assign to the queue. Relevant only if auto-bind-dlq is true string false DLX dead-letter-exchange-type The type of the DLX to assign to the queue. Relevant only if auto-bind-dlq is true string false direct dead-letter-queue-name The name of the DLQ; if not supplied will default to the queue name with '.dlq' appended string false dead-letter-routing-key A dead letter routing key to assign to the queue; if not supplied will default to the queue name string false dlx.declare Whether to declare the dead letter exchange binding. Relevant only if auto-bind-dlq is true; set to false if these are expected to be set up independently boolean false false exchange.auto-delete Whether the exchange should be deleted after use boolean false false exchange.declare Whether to declare the exchange; set to false if the exchange is expected to be set up independently boolean false true exchange.durable Whether the exchange is durable boolean false true exchange.name The exchange that messages are published to or consumed from. If not set, the channel name is used string false exchange.type The exchange type: direct, fanout, headers or topic (default) string false topic failure-strategy The failure strategy to apply when a RabbitMQ message is nacked. Accepted values are fail , accept , reject (default) string false reject handshake-timeout The AMQP 0-9-1 protocol handshake timeout (ms) int false 10000 host (rabbitmq-host) The broker hostname string false localhost include-properties Whether to include properties when a broker message is passed on the event bus boolean false false keep-most-recent Whether to discard old messages instead of recent ones boolean false false max-incoming-internal-queue-size The maximum size of the incoming internal queue int false network-recovery-interval How long (ms) will automatic recovery wait before attempting to reconnect int false 5000 password (rabbitmq-password) The password used to authenticate to the broker string false port (rabbitmq-port) The broker port int false 5672 queue.auto-delete Whether the queue should be deleted after use boolean false false queue.declare Whether to declare the queue and binding; set to false if these are expected to be set up independently boolean false true queue.durable Whether the queue is durable boolean false true queue.exclusive Whether the queue is for exclusive use boolean false false queue.name The queue from which messages are consumed. string true queue.ttl If specified, the time (ms) for which a message can remain in the queue undelivered before it is dead long false reconnect-attempts (rabbitmq-reconnect-attempts) The number of reconnection attempts int false 100 reconnect-interval (rabbitmq-reconnect-interval) The interval (in seconds) between two reconnection attempts int false 10 requested-channel-max The initially requested maximum channel number int false 2047 requested-heartbeat The initially requested heartbeat interval (seconds), zero for none int false 60 routing-keys A comma-separated list of routing keys to bind the queue to the exchange string false # ssl (rabbitmq-ssl) Whether or not the connection should use SSL boolean false false tracing.attribute-headers A comma-separated list of headers that should be recorded as span attributes. Relevant only if tracing.enabled=true string false `` tracing.enabled Whether tracing is enabled (default) or disabled boolean false true trust-all (rabbitmq-trust-all) Whether to skip trust certificate verification boolean false false trust-store-password (rabbitmq-trust-store-password) The password of the JKS trust store string false trust-store-path (rabbitmq-trust-store-path) The path to a JKS trust store string false use-nio Whether usage of NIO Sockets is enabled boolean false false user The user name to use when connecting to the broker string false guest username (rabbitmq-username) The username used to authenticate to the broker string false virtual-host (rabbitmq-virtual-host) The virtual host to use when connecting to the broker string false / To use an existing queue , you need to configure the queue.name attribute. For example, if you have a RabbitMQ broker already configured with a queue called peopleQueue that you wish to read messages from, you need the following configuration: 1 2 mp.messaging.incoming.people.connector = smallrye-rabbitmq mp.messaging.incoming.people.queue.name = peopleQueue If you want RabbitMQ to create the queue for you but bind it to an existing topic exchange people , you need the following configuration: 1 2 3 mp.messaging.incoming.people.connector = smallrye-rabbitmq mp.messaging.incoming.people.queue.name = peopleQueue mp.messaging.incoming.people.queue.declare = true Note In the above the channel name people is implicitly assumed to be the name of the exchange; if this is not the case you would need to name the exchange explicitly using the exchange.name property. If you want RabbitMQ to create the people exchange, queue and binding, you need the following configuration: 1 2 3 4 5 mp.messaging.incoming.people.connector = smallrye-rabbitmq mp.messaging.incoming.people.exchange.declare = true mp.messaging.incoming.people.queue.name = peopleQueue mp.messaging.incoming.people.queue.declare = true mp.messaging.incoming.people.queue.routing-keys = tall,short In the above we have used an explicit list of routing keys rather than the default ( # ). Each component of the list creates a separate binding between the queue and the exchange, so in the case above we would have two bindings; one based on a routing key of tall , the other based on one of short . Note The default value of routing-keys is # (indicating a match against all possible routing keys) which is only appropriate for topic Exchanges. If you are using other types of exchange and/or need to declare queue bindings, you\u2019ll need to supply a valid value for the exchange in question.","title":"Configuration Reference"},{"location":"rabbitmq/sending-messages-to-rabbitmq/","text":"Sending messages to RabbitMQ The RabbitMQ connector can write Reactive Messaging Messages as RabbitMQ Messages. Note In this context, the reactive messaging concept of a Channel is realised as a RabbitMQ Exchange . Example Let\u2019s imagine you have a RabbitMQ broker running, and accessible using the rabbitmq:5672 address (by default it would use localhost:5672 ). Configure your application to send the messages from the prices channel as a RabbitMQ Message as follows: 1 2 3 4 5 6 7 rabbitmq-host=rabbitmq # <1> rabbitmq-port=5672 # <2> rabbitmq-username=my-username # <3> rabbitmq-password=my-password # <4> mp.messaging.outgoing.prices.connector=smallrye-rabbitmq # <5> mp.messaging.outgoing.prices.default-routing-key=normal # <6> Configures the broker/router host name. You can do it per channel (using the host attribute) or globally using rabbitmq-host Configures the broker/router port. You can do it per channel (using the port attribute) or globally using rabbitmq-port . The default is 5672 . Configures the broker/router username if required. You can do it per channel (using the username attribute) or globally using rabbitmq-username . Configures the broker/router password if required. You can do it per channel (using the password attribute) or globally using rabbitmq-password . Instructs the prices channel to be managed by the RabbitMQ connector Supplies the default routing key to be included in outbound messages; this will be if the \"raw payload\" form of message sending is used (see below). Note You don\u2019t need to set the RabbitMQ exchange name. By default, it uses the channel name ( prices ) as the name of the exchange to send messages to. You can configure the exchange.name attribute to override it. Then, your application can send Message<Double> to the prices channel. It can use double payloads as in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package rabbitmq.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class RabbitMQPriceProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Double > generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()); } } Or, you can send Message<Double> , which affords the opportunity to explicitly specify metadata on the outgoing message: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package rabbitmq.outbound ; import java.time.Duration ; import java.time.ZonedDateTime ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Metadata ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; import io.smallrye.reactive.messaging.rabbitmq.OutgoingRabbitMQMetadata ; @ApplicationScoped public class RabbitMQPriceMessageProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Message < Double >> generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> Message . of ( random . nextDouble (), Metadata . of ( new OutgoingRabbitMQMetadata . Builder () . withRoutingKey ( \"normal\" ) . withTimestamp ( ZonedDateTime . now ()) . build ()))); } } Serialization When sending a Message<T> , the connector converts the message into a RabbitMQ Message. The payload is converted to the RabbitMQ Message body. T RabbitMQ Message Body primitive types or UUID / String String value with content_type set to text/plain JsonObject or JsonArray Serialized String payload with content_type set to application/json io.vertx.mutiny.core.buffer.Buffer Binary content, with content_type set to application/octet-stream byte[] Binary content, with content_type set to application/octet-stream Any other class The payload is converted to JSON (using a Json Mapper) then serialized with content_type set to application/json If the message payload cannot be serialized to JSON, the message is nacked . Outbound Metadata When sending Messages , you can add an instance of OutgoingRabbitMQMetadata to influence how the message is handled by RabbitMQ. For example, you can configure the routing key, timestamp and headers: 1 2 3 4 5 6 7 8 final OutgoingRabbitMQMetadata metadata = new OutgoingRabbitMQMetadata . Builder () . withHeader ( \"my-header\" , \"xyzzy\" ) . withRoutingKey ( \"urgent\" ) . withTimestamp ( ZonedDateTime . now ()) . build (); // Add `metadata` to the metadata of the outgoing message. return Message . of ( \"Hello\" , Metadata . of ( metadata )); Acknowledgement By default, the Reactive Messaging Message is acknowledged when the broker acknowledges the message. Configuration Reference Attribute ( alias ) Description Type Mandatory Default automatic-recovery-enabled Whether automatic connection recovery is enabled boolean false false automatic-recovery-on-initial-connection Whether automatic recovery on initial connections is enabled boolean false true client-options-name (rabbitmq-client-options-name) The name of the RabbitMQ Client Option bean used to customize the RabbitMQ client configuration string false connection-timeout The TCP connection timeout (ms); 0 is interpreted as no timeout int false 60000 credentials-provider-name (rabbitmq-credentials-provider-name) The name of the RabbitMQ Credentials Provider bean used to provide dynamic credentials to the RabbitMQ client string false default-routing-key The default routing key to use when sending messages to the exchange string false `` default-ttl If specified, the time (ms) sent messages can remain in queues undelivered before they are dead long false exchange.auto-delete Whether the exchange should be deleted after use boolean false false exchange.declare Whether to declare the exchange; set to false if the exchange is expected to be set up independently boolean false true exchange.durable Whether the exchange is durable boolean false true exchange.name The exchange that messages are published to or consumed from. If not set, the channel name is used string false exchange.type The exchange type: direct, fanout, headers or topic (default) string false topic handshake-timeout The AMQP 0-9-1 protocol handshake timeout (ms) int false 10000 host (rabbitmq-host) The broker hostname string false localhost include-properties Whether to include properties when a broker message is passed on the event bus boolean false false max-inflight-messages The maximum number of messages to be written to RabbitMQ concurrently; must be a positive number long false 1024 max-outgoing-internal-queue-size The maximum size of the outgoing internal queue int false network-recovery-interval How long (ms) will automatic recovery wait before attempting to reconnect int false 5000 password (rabbitmq-password) The password used to authenticate to the broker string false port (rabbitmq-port) The broker port int false 5672 reconnect-attempts (rabbitmq-reconnect-attempts) The number of reconnection attempts int false 100 reconnect-interval (rabbitmq-reconnect-interval) The interval (in seconds) between two reconnection attempts int false 10 requested-channel-max The initially requested maximum channel number int false 2047 requested-heartbeat The initially requested heartbeat interval (seconds), zero for none int false 60 ssl (rabbitmq-ssl) Whether or not the connection should use SSL boolean false false tracing.attribute-headers A comma-separated list of headers that should be recorded as span attributes. Relevant only if tracing.enabled=true string false `` tracing.enabled Whether tracing is enabled (default) or disabled boolean false true trust-all (rabbitmq-trust-all) Whether to skip trust certificate verification boolean false false trust-store-password (rabbitmq-trust-store-password) The password of the JKS trust store string false trust-store-path (rabbitmq-trust-store-path) The path to a JKS trust store string false use-nio Whether usage of NIO Sockets is enabled boolean false false user The user name to use when connecting to the broker string false guest username (rabbitmq-username) The username used to authenticate to the broker string false virtual-host (rabbitmq-virtual-host) The virtual host to use when connecting to the broker string false / Using existing destinations To use an existing exchange , you may need to configure the exchange.name attribute. For example, if you have a RabbitMQ broker already configured with an exchange called people that you wish to send messages to, you need the following configuration: 1 mp.messaging.outgoing.people.connector = smallrye-rabbitmq You would need to configure the exchange.name attribute, if the exchange name were not the channel name: 1 2 mp.messaging.outgoing.people-out.connector = smallrye-rabbitmq mp.messaging.outgoing.people-out.exchange.name = people If you want RabbitMQ to create the people exchange, you need the following configuration: 1 2 3 mp.messaging.outgoing.people-out.connector = smallrye-amqp mp.messaging.outgoing.people-out.exchange.name = people mp.messaging.outgoing.people-out.exchange.declare = true Note The above example will create a topic exchange and use an empty default routing-key (unless overridden programatically using outgoing metadata for the message). If you want to create a different type of exchange or have a different default routing key, then the exchange.type and default-routing-key properties need to be explicitly specified.","title":"Sending messages"},{"location":"rabbitmq/sending-messages-to-rabbitmq/#sending-messages-to-rabbitmq","text":"The RabbitMQ connector can write Reactive Messaging Messages as RabbitMQ Messages. Note In this context, the reactive messaging concept of a Channel is realised as a RabbitMQ Exchange .","title":"Sending messages to RabbitMQ"},{"location":"rabbitmq/sending-messages-to-rabbitmq/#example","text":"Let\u2019s imagine you have a RabbitMQ broker running, and accessible using the rabbitmq:5672 address (by default it would use localhost:5672 ). Configure your application to send the messages from the prices channel as a RabbitMQ Message as follows: 1 2 3 4 5 6 7 rabbitmq-host=rabbitmq # <1> rabbitmq-port=5672 # <2> rabbitmq-username=my-username # <3> rabbitmq-password=my-password # <4> mp.messaging.outgoing.prices.connector=smallrye-rabbitmq # <5> mp.messaging.outgoing.prices.default-routing-key=normal # <6> Configures the broker/router host name. You can do it per channel (using the host attribute) or globally using rabbitmq-host Configures the broker/router port. You can do it per channel (using the port attribute) or globally using rabbitmq-port . The default is 5672 . Configures the broker/router username if required. You can do it per channel (using the username attribute) or globally using rabbitmq-username . Configures the broker/router password if required. You can do it per channel (using the password attribute) or globally using rabbitmq-password . Instructs the prices channel to be managed by the RabbitMQ connector Supplies the default routing key to be included in outbound messages; this will be if the \"raw payload\" form of message sending is used (see below). Note You don\u2019t need to set the RabbitMQ exchange name. By default, it uses the channel name ( prices ) as the name of the exchange to send messages to. You can configure the exchange.name attribute to override it. Then, your application can send Message<Double> to the prices channel. It can use double payloads as in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package rabbitmq.outbound ; import java.time.Duration ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; @ApplicationScoped public class RabbitMQPriceProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Double > generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> random . nextDouble ()); } } Or, you can send Message<Double> , which affords the opportunity to explicitly specify metadata on the outgoing message: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package rabbitmq.outbound ; import java.time.Duration ; import java.time.ZonedDateTime ; import java.util.Random ; import javax.enterprise.context.ApplicationScoped ; import org.eclipse.microprofile.reactive.messaging.Message ; import org.eclipse.microprofile.reactive.messaging.Metadata ; import org.eclipse.microprofile.reactive.messaging.Outgoing ; import io.smallrye.mutiny.Multi ; import io.smallrye.reactive.messaging.rabbitmq.OutgoingRabbitMQMetadata ; @ApplicationScoped public class RabbitMQPriceMessageProducer { private Random random = new Random (); @Outgoing ( \"prices\" ) public Multi < Message < Double >> generate () { // Build an infinite stream of random prices // It emits a price every second return Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . map ( x -> Message . of ( random . nextDouble (), Metadata . of ( new OutgoingRabbitMQMetadata . Builder () . withRoutingKey ( \"normal\" ) . withTimestamp ( ZonedDateTime . now ()) . build ()))); } }","title":"Example"},{"location":"rabbitmq/sending-messages-to-rabbitmq/#serialization","text":"When sending a Message<T> , the connector converts the message into a RabbitMQ Message. The payload is converted to the RabbitMQ Message body. T RabbitMQ Message Body primitive types or UUID / String String value with content_type set to text/plain JsonObject or JsonArray Serialized String payload with content_type set to application/json io.vertx.mutiny.core.buffer.Buffer Binary content, with content_type set to application/octet-stream byte[] Binary content, with content_type set to application/octet-stream Any other class The payload is converted to JSON (using a Json Mapper) then serialized with content_type set to application/json If the message payload cannot be serialized to JSON, the message is nacked .","title":"Serialization"},{"location":"rabbitmq/sending-messages-to-rabbitmq/#outbound-metadata","text":"When sending Messages , you can add an instance of OutgoingRabbitMQMetadata to influence how the message is handled by RabbitMQ. For example, you can configure the routing key, timestamp and headers: 1 2 3 4 5 6 7 8 final OutgoingRabbitMQMetadata metadata = new OutgoingRabbitMQMetadata . Builder () . withHeader ( \"my-header\" , \"xyzzy\" ) . withRoutingKey ( \"urgent\" ) . withTimestamp ( ZonedDateTime . now ()) . build (); // Add `metadata` to the metadata of the outgoing message. return Message . of ( \"Hello\" , Metadata . of ( metadata ));","title":"Outbound Metadata"},{"location":"rabbitmq/sending-messages-to-rabbitmq/#acknowledgement","text":"By default, the Reactive Messaging Message is acknowledged when the broker acknowledges the message.","title":"Acknowledgement"},{"location":"rabbitmq/sending-messages-to-rabbitmq/#configuration-reference","text":"Attribute ( alias ) Description Type Mandatory Default automatic-recovery-enabled Whether automatic connection recovery is enabled boolean false false automatic-recovery-on-initial-connection Whether automatic recovery on initial connections is enabled boolean false true client-options-name (rabbitmq-client-options-name) The name of the RabbitMQ Client Option bean used to customize the RabbitMQ client configuration string false connection-timeout The TCP connection timeout (ms); 0 is interpreted as no timeout int false 60000 credentials-provider-name (rabbitmq-credentials-provider-name) The name of the RabbitMQ Credentials Provider bean used to provide dynamic credentials to the RabbitMQ client string false default-routing-key The default routing key to use when sending messages to the exchange string false `` default-ttl If specified, the time (ms) sent messages can remain in queues undelivered before they are dead long false exchange.auto-delete Whether the exchange should be deleted after use boolean false false exchange.declare Whether to declare the exchange; set to false if the exchange is expected to be set up independently boolean false true exchange.durable Whether the exchange is durable boolean false true exchange.name The exchange that messages are published to or consumed from. If not set, the channel name is used string false exchange.type The exchange type: direct, fanout, headers or topic (default) string false topic handshake-timeout The AMQP 0-9-1 protocol handshake timeout (ms) int false 10000 host (rabbitmq-host) The broker hostname string false localhost include-properties Whether to include properties when a broker message is passed on the event bus boolean false false max-inflight-messages The maximum number of messages to be written to RabbitMQ concurrently; must be a positive number long false 1024 max-outgoing-internal-queue-size The maximum size of the outgoing internal queue int false network-recovery-interval How long (ms) will automatic recovery wait before attempting to reconnect int false 5000 password (rabbitmq-password) The password used to authenticate to the broker string false port (rabbitmq-port) The broker port int false 5672 reconnect-attempts (rabbitmq-reconnect-attempts) The number of reconnection attempts int false 100 reconnect-interval (rabbitmq-reconnect-interval) The interval (in seconds) between two reconnection attempts int false 10 requested-channel-max The initially requested maximum channel number int false 2047 requested-heartbeat The initially requested heartbeat interval (seconds), zero for none int false 60 ssl (rabbitmq-ssl) Whether or not the connection should use SSL boolean false false tracing.attribute-headers A comma-separated list of headers that should be recorded as span attributes. Relevant only if tracing.enabled=true string false `` tracing.enabled Whether tracing is enabled (default) or disabled boolean false true trust-all (rabbitmq-trust-all) Whether to skip trust certificate verification boolean false false trust-store-password (rabbitmq-trust-store-password) The password of the JKS trust store string false trust-store-path (rabbitmq-trust-store-path) The path to a JKS trust store string false use-nio Whether usage of NIO Sockets is enabled boolean false false user The user name to use when connecting to the broker string false guest username (rabbitmq-username) The username used to authenticate to the broker string false virtual-host (rabbitmq-virtual-host) The virtual host to use when connecting to the broker string false /","title":"Configuration Reference"},{"location":"rabbitmq/sending-messages-to-rabbitmq/#using-existing-destinations","text":"To use an existing exchange , you may need to configure the exchange.name attribute. For example, if you have a RabbitMQ broker already configured with an exchange called people that you wish to send messages to, you need the following configuration: 1 mp.messaging.outgoing.people.connector = smallrye-rabbitmq You would need to configure the exchange.name attribute, if the exchange name were not the channel name: 1 2 mp.messaging.outgoing.people-out.connector = smallrye-rabbitmq mp.messaging.outgoing.people-out.exchange.name = people If you want RabbitMQ to create the people exchange, you need the following configuration: 1 2 3 mp.messaging.outgoing.people-out.connector = smallrye-amqp mp.messaging.outgoing.people-out.exchange.name = people mp.messaging.outgoing.people-out.exchange.declare = true Note The above example will create a topic exchange and use an empty default routing-key (unless overridden programatically using outgoing metadata for the message). If you want to create a different type of exchange or have a different default routing key, then the exchange.type and default-routing-key properties need to be explicitly specified.","title":"Using existing destinations"}]}